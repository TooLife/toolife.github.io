{"meta":{"title":"个人博客","subtitle":{"description":"认真生活, 快乐工作.","keywords":{"author":"Jason Tang","language":{"timezone":null}}},"description":"","author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"阿里云服务器搭建以及Linux安装软件小结","date":"2018-07-18T11:52:44.000Z","updated":"2018-07-18T12:23:38.264Z","comments":true,"path":"阿里云服务器搭建以及Linux安装软件小结/index.html","permalink":"http://yoursite.com/阿里云服务器搭建以及Linux安装软件小结/index.html","excerpt":"","text":""},{"title":"定时任务调度工具之Timer","date":"2018-07-18T12:46:40.000Z","updated":"2018-07-18T12:46:40.094Z","comments":true,"path":"定时任务调度工具之Timer/index.html","permalink":"http://yoursite.com/定时任务调度工具之Timer/index.html","excerpt":"","text":""},{"title":"All tags","date":"2018-07-18T11:48:53.000Z","updated":"2018-07-18T11:51:02.088Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"定时任务调度工具之Timer","slug":"定时任务调度工具之Timer","date":"2018-07-18T12:46:30.000Z","updated":"2018-07-18T12:49:29.423Z","comments":true,"path":"2018/07/18/定时任务调度工具之Timer/","link":"","permalink":"http://yoursite.com/2018/07/18/定时任务调度工具之Timer/","excerpt":"是什么是定时任务调度？ 基于给定的时间点、给定的时间间隔或者给定的执行次数自动执行任务。 Timer 由JDK自带提供！","text":"是什么是定时任务调度？ 基于给定的时间点、给定的时间间隔或者给定的执行次数自动执行任务。 Timer 由JDK自带提供！ Timer的定义 有且仅有一个后台线程对多个业务线程进行定时定频率的调度 Timer定时调度任务的四种用法首先，创建一个MyTimerTask类，继承TimerTask 12345678910111213141516171819public class MyTimerTask extends TimerTask &#123; private String name; public MyTimerTask(String name) &#123; this.name = name; &#125; @Override public void run() &#123; System.out.println(\"current name is \" + name); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; schedule(task, time) : 在时间等于或者超过time的时候执行，且执行一次task。 1234567891011// 创建一个Timer实例Timer timer = new Timer();// 创建一个TimerTask实例MyTimerTask task = new MyTimerTask(\"s1\");/** * 在时间等于或者超过time的时候执行，且执行一次task */Calendar calendar = Calendar.getInstance();// 在当前时间的5秒后执行该任务calendar.add(Calendar.SECOND, 5);timer.schedule(task, calendar.getTime()); schedule(task, time, period) : 在时间等于或者超过time的时候首次执行task，之后每隔period毫秒重复执行task 123456789// 创建一个Timer实例Timer timer = new Timer();// 创建一个TimerTask实例MyTimerTask task = new MyTimerTask(\"s2\");Calendar calendar = Calendar.getInstance();/** * 在时间等于或者超过time的时候首次执行task，之后每隔period毫秒重复执行task */timer.schedule(task, calendar.getTime(), 3000); schedule(task, delay) : 等待delay毫秒后执行且执行一次task 12345678// 创建一个Timer实例Timer timer = new Timer();// 创建一个TimerTask实例MyTimerTask task = new MyTimerTask(\"s3\");/** * 等待delay毫秒后执行且执行一次task */timer.schedule(task, 3000); schedule(task, delay, period) : 等待等于或者超过delay毫秒后首次执行task 之后每隔period毫秒重复执行task 12345678// 创建一个Timer实例Timer timer = new Timer();// 创建一个TimerTask实例MyTimerTask task = new MyTimerTask(\"小米\");/** * 等待delay毫秒后首次执行task 之后每隔period毫秒重复执行task */timer.schedule(task, 3000, 2000); scheduleAtFixedRate的两种用法 scheduleAtFixedRate(TimerTask task, Date firstTime, long period) : 时间等于或者超过time的时候首次执行task，之后每隔period毫秒重复执行task 123456789// 创建一个Timer实例Timer timer = new Timer();// 创建一个TimerTask实例MyTimerTask task = new MyTimerTask(\"scheduleAtFixedRate1\");Calendar calendar = Calendar.getInstance();/** * 时间等于或者超过time的时候首次执行task，之后每隔period毫秒重复执行task */timer.scheduleAtFixedRate(task, calendar.getTime(), 2000); scheduleAtFixedRate(TimerTask task, long delay, long period):等待等于或者超过delay毫秒后首次执行task 之后每隔period毫秒重复执行task 12345678// 创建一个Timer实例Timer timer = new Timer();// 创建一个TimerTask实例MyTimerTask task = new MyTimerTask(\"scheduleAtFixedRate2\");/** * 等待等于或者超过delay毫秒后首次执行task 之后每隔period毫秒重复执行task */timer.scheduleAtFixedRate(task, 3000, 2000); TimerTask其他函数介绍 cancel() 取消当前TimerTask中的任务 scheduleExecutionTime() 返回此任务实际执行的已安排的执行时间 Timer其他函数介绍 cancel() 终止此定时器，丢弃所有当前已安排的任务 **int purge() 从此计时器的任务队列中移除所有==已取消==的任务，返回值是从队列中移除的任务数","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"Timer","slug":"Timer","permalink":"http://yoursite.com/tags/Timer/"},{"name":"code","slug":"code","permalink":"http://yoursite.com/tags/code/"}]},{"title":"阿里云服务器搭建以及Linux安装软件小结","slug":"阿里云服务器搭建以及Linux安装软件小结","date":"2018-07-18T11:52:30.000Z","updated":"2018-07-18T13:04:20.745Z","comments":true,"path":"2018/07/18/阿里云服务器搭建以及Linux安装软件小结/","link":"","permalink":"http://yoursite.com/2018/07/18/阿里云服务器搭建以及Linux安装软件小结/","excerpt":"购买 首先，在阿里云官网购买云服务器ESC (https://promotion.aliyun.com/ntms/campus2017.html?spm=5176.8142029.631162.75.68606d3e9rbcEa) 。这个网址是学生优惠，非常划算！","text":"购买 首先，在阿里云官网购买云服务器ESC (https://promotion.aliyun.com/ntms/campus2017.html?spm=5176.8142029.631162.75.68606d3e9rbcEa) 。这个网址是学生优惠，非常划算！ 配置密码 配置连接(登录)服务器密码、设置远程连接密码 连接 购买好云服务器，设置好密码之后，再远程连接云服务器 ( 我服务器镜像是Linux Center OS 7.3 64位 )，点击远程连接，就跳转到了一个命令行窗口. 连接….. 也可以通过SecureCRT客户端连接，或者本机终端连接 推荐一个好用的插件：fish 优点：让你的命令行具有提示功能，还能记录你输入过得命令。缺点就是有些命令识别不了，需要退出fish模式下再执行😆 阿里云服务器防火墙与端口 阿里云服务器信息 Linux Center OS 7.3 x86_64 前言，Center OS 7.0 以后默认使用的是firewall作为防火墙，而Center OS 7.0以前，使用 iptables 作为防火墙，所以我们在开启、关闭、刷新服务以及打开端口都变了，使用systemctl命令。systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体 firewalld的基本使用， 12345启动: systemctl start firewalld关闭: systemctl stop firewalld查看状态: systemctl status firewalld 开机禁用: systemctl disable firewalld开机启用: systemctl enable firewalld 配置firewalld-cmd 12345678910查看版本: firewall-cmd --version查看帮助: firewall-cmd --help显示状态: firewall-cmd --state查看所有打开的端口: firewall-cmd --zone=public --list-ports更新防火墙规则: firewall-cmd --reload查看区域信息: firewall-cmd --get-active-zones查看指定接口所属区域: firewall-cmd --get-zone-of-interface=eth0拒绝所有包:firewall-cmd --panic-on取消拒绝状态: firewall-cmd --panic-off查看是否拒绝: firewall-cmd --query-panic systemctl命令介绍 123456789启动一个服务：systemctl start firewalld.service关闭一个服务：systemctl stop firewalld.service重启一个服务：systemctl restart firewalld.service显示一个服务的状态：systemctl status firewalld.service在开机时启用一个服务：systemctl enable firewalld.service在开机时禁用一个服务：systemctl disable firewalld.service查看服务是否开机启动：systemctl is-enabled firewalld.service查看已启动的服务列表：systemctl list-unit-files|grep enabled查看启动失败的服务列表：systemctl --failed 开启、查看、关闭端口 1234开放80端口：firewall-cmd --zone=public --add-port=80/tcp --permanent查看80端口是否开放：firewall-cmd --zone= public --query-port=80/tcp关闭80端口：firewall-cmd --zone= public --remove-port=80/tcp --permanent重新载入：firewall-cmd --reload 既然端口已经打开了，然而还是访问不了！！！ 1http://x.x.x.x:80 在阿里云本实例安全组中，添加安全组规则 再次访问还是访问不了，原因是：缺少Apache服务，接下来安装 12345安装：yum install httpd httpd-devel设置开机自启：chkconfig --levels 235 httpd on开启Apache服务：systemctl start httpd再次访问 http://x.x.x.x:80，ok了 安装JDK、Tomcat 安装前言，在阿里云服务器安装JDK、Tomcat的一系列Bug。在我个人的本机上使用的是Center OS 6.4 ，这里使用的是iptables作为防火墙。但安装程序都是一样的，期间肯定会出现Bug。come on，一步一步来安装JDK与Tomcat。 安装JDK 先准备好Linux下JDK安装包 (jdk-8u171-linux-i586.tar) 检查系统上是否安装了jdk(若安装了就需要先卸载再使用我们自己的) 1java -version 查看出安装的java的软件包 1rpm -qa | grep java 卸载jdk 12rpm -e --nodeps java-1.6.0-openjdk-1.6.0.0-1.66.1.13.0.el6.i686rpm -e --nodeps java-1.7.0-openjdk-1.7.0.45-2.4.3.3.el6.i686 tzdata-java-2013g-1.el6.noarch 在 /usr/local 新建一个文件夹 java,存放jdk 1mkdir /usr/local/java 移动 jdk-8u171-linux-i586.tar 到 /usr/local/java下 1mv jdk-8u171-linux-i586.tar /usr/local/java 进入 /usr/local/java 目录,解压jdk到当前目录 12cd /usr/local/javatar -xvf jdk-8u171-linux-i586.tar 配置环境变量 12345vi /etc/profile # 在文件的最后面添加如下代码export JAVA_HOME=/usr/local/java/jdk1.7.0_72export PATH=$JAVA_HOME/bin:$PATH 保存退出 1# 在vim下，按shift + : 调出底部命令，输入wq (保存退出)，回车ok 重新加载配置文件 1source /etc/profile 查看jdk是否安装成功 12java -version[root@jason ~]# -bash: /usr/java/jdk1.7.0_71/bin/java: /lib/ld-linux.so.2: bad ELF interpreter: No such file or directory 问题来了，出现了错误：No such file or directory。 原因：没有那个文件或目录，需要安装glibc 终端输入下面的命令，安装好glibc，问题解决,，再次查看jdk版本 1sudo yum install glibc.i686 1234[root@jason ~]# java -versionjava version \"1.8.0_171\"Java(TM) SE Runtime Environment (build 1.8.0_171-b11)Java HotSpot(TM) Client VM (build 25.171-b11, mixed mode) jdk安装完成！ 安装Tomcat 先准备好apache-tomcat安装包 (apache-tomcat-7.0.52.tar.gz) 在 /usr/local 新建一个文件夹tomcat 1mkdir /usr/local/tomcat 移动 apache-tomcat…tar.gz 到 /usr/local/tomcat 1mv apache-tomcat-7.0.52.tar.gz /usr/local/tomcat/ 进入/usr/local/tomcat目录,解压Tomcat 12cd /usr/local/tomcattar -zxvf apache-tomcat-7.0.52.tar.gz 进入 /usr/local/tomcat/apache-tomcat-7.0.52/bin 1cd /usr/local/tomcat/apache-tomcat-7.0.52/bin 启动tomcat(执行startup.sh文件) 1234方式1: sh startup.sh方式2: ./startup.sh 修改防火墙的规则，放行8080端口，同时在阿里云安全组规则中添加8080端口 1firewall-cmd --add-port=8888/tcp --permanent 查看服务器已开启的tcp端口 12345678[root@jason] # netstat -ntlpActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program nametcp 0 0 0.0.0.0:8009 0.0.0.0:* LISTEN 3833/javatcp 0 0 0.0.0.0:8080 0.0.0.0:* LISTEN 3833/javatcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 739/httpdtcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 2101/sshdtcp 0 0 127.0.0.1:8005 0.0.0.0:* LISTEN 3833/java 访问8080端口 1http://x.x.x.x:8080","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Center OS","slug":"Center-OS","permalink":"http://yoursite.com/tags/Center-OS/"},{"name":"云服务器","slug":"云服务器","permalink":"http://yoursite.com/tags/云服务器/"},{"name":"软件","slug":"软件","permalink":"http://yoursite.com/tags/软件/"}]}]}