<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Spring框架简介</title>
      <link href="/2018/07/20/Spring%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/"/>
      <url>/2018/07/20/Spring%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<hr><a id="more"></a><h3 id="spring框架的特征"><a href="#spring框架的特征" class="headerlink" title="spring框架的特征"></a>spring框架的特征</h3><ol><li>轻量级</li><li>IOC(控制反转思想),非侵入式</li><li>AOP(面向切面编程思想)</li><li>容器/工厂</li></ol><h3 id="谈谈对spring的理解"><a href="#谈谈对spring的理解" class="headerlink" title="谈谈对spring的理解"></a>谈谈对spring的理解</h3><ul><li>spring是一个开源框架，为简化企业级应用开发而生</li><li>spring可以<strong>使用简单的javaBean</strong>实现只有EJB才能实现的功能</li><li>spring是一个<strong>IOC(控制反转)</strong>和<strong>AOP(面向切面编程)</strong>容器框架</li><li>方便解耦，简化开发<ul><li>spring就是一个大工厂，可以将所有对象创建和依赖关系维护，交给spring管理，AOP编程的支持</li></ul></li><li>AOP编程支持<ul><li>spring提供面向切面编程，可以方便的实现对程序进行权限拦截，运行监控等功能</li></ul></li><li>方便程序测试<ul><li>spring对Junit4支持，可以通过注解方便测试</li></ul></li><li>方便集成各种优秀框架<ul><li>spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持(MyBatis、Struts、Hibernate….)</li></ul></li><li>声明式事物的支持<ul><li>只需要通过配置就可以完成对事物的管理，无需手动编程</li></ul></li></ul><h3 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h3><blockquote><p> 1.<strong>spring 核心容器的最基本jar包</strong></p></blockquote><ul><li><strong>Beans</strong><ul><li>spring-beans-4.2.4.RELEASE.jar</li></ul></li><li><strong>Core</strong><ul><li>spring-context-4.2.4.RELEASE.jar</li></ul></li><li><strong>Context</strong><ul><li>spring-core-4.2.4.RELEASE.jar</li></ul></li><li><strong>Expression Language</strong><ul><li>spring-expression-4.2.4.RELEASE.jar</li></ul></li></ul><blockquote><p>  2.spring框架所需的日志包</p></blockquote><ul><li>默认采用apache commons-logging(JCL)日志框架+log4j的日志实现，还需要添加log4j的配置文件。 </li></ul><h3 id="控制反转-IOC-inversion-of-control"><a href="#控制反转-IOC-inversion-of-control" class="headerlink" title="控制反转 IOC (inversion of control)"></a>控制反转 IOC (inversion of control)</h3><ul><li>传统的java开发模式中，当需要一个对象时，我们会自己使用<u><strong>new</strong></u> 或者 <strong><u>getInstance</u></strong>等直接或间接调用高中方法创建对象。而在spring开发模式中，spring容器使用了<strong><u>工厂模式</u></strong>为我们创建了所需要的对象，不需要我们自己创建，直接调用spring提供的对象即可，这就是<strong>控制反转思想。也就是将对象创建权反转给spring，解决程序的耦合性(传统的java开中，service层与dao层关联依赖过多，导致耦合性大大的增加)。由spring创建对象的过程,就是IOC</strong></li></ul><blockquote><p>  创建spring的核心配置文件 <strong>applicationContext.xml</strong></p></blockquote><ul><li>引入约束</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在beans中配置DAO or Service….其他Bean</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">   IOC:控制反转</span></span><br><span class="line"><span class="comment">   bean: spring工厂帮你new的一个对象(反射机制)</span></span><br><span class="line"><span class="comment">   id/name: 标识对象的名称, 通过该名称来获取bean对象</span></span><br><span class="line"><span class="comment">   class: 要new对象类的全限定名</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user_dao"</span> <span class="attr">class</span>=<span class="string">"com.jason.spring.dao.impl.UserDaoImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user_service"</span> <span class="attr">class</span>=<span class="string">"com.jason.spring.service.impl.UserServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO 创建Spring的工厂, 加载applicationContext.xml配置文件</span></span><br><span class="line">    ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    <span class="comment">// TODO 通过标识对象的名称获得实例</span></span><br><span class="line">    IUserDao dao = (IUserDao) ac.getBean(<span class="string">"user_dao"</span>);</span><br><span class="line">    <span class="comment">// TODO 调用方法</span></span><br><span class="line">    dao.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖注入-DI-Dependency-Injection"><a href="#依赖注入-DI-Dependency-Injection" class="headerlink" title="依赖注入 DI (Dependency Injection )"></a>依赖注入 DI (Dependency Injection )</h3><ul><li><p><strong>spring使用JavaBean对象的set方法或者构造函数为我们在创建所需对象时将其属性自动设置所需要值的过程，就是依赖注入思想</strong></p></li><li><p>在业务层中定义一个dao层属性，并添加set方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IUserDao userDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(IUserDao dao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = dao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHelloService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置spring容器</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">  DI:依赖注入:由spring创建对象时，将一个对象注入到另一个对象的过程就是DI</span></span><br><span class="line"><span class="comment">  property: 属性注入</span></span><br><span class="line"><span class="comment">   name: 表示set方法的名称</span></span><br><span class="line"><span class="comment">   ref: 表示spring容器创建对象的表示名称，进行注入，表示对象的注入</span></span><br><span class="line"><span class="comment">   value: 表示值的注入</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user_service"</span> <span class="attr">class</span>=<span class="string">"com.jason.spring.service.impl.UserServiceImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDao"</span> <span class="attr">ref</span>=<span class="string">"user_dao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO 依赖注入</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    IUserService service = (IUserService) ac.getBean(<span class="string">"user_service"</span>);</span><br><span class="line">    service.sayHelloService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IOC-与-DI-的区别"><a href="#IOC-与-DI-的区别" class="headerlink" title="IOC 与 DI 的区别"></a>IOC 与 DI 的区别</h3><ul><li>IOC : 控制反转，将对象的创建权交给spring;</li><li>DI : 依赖注入，在spring创建这个类的过程中，把这个类所依赖的属性设置进来;</li></ul><h3 id="spring的工厂类"><a href="#spring的工厂类" class="headerlink" title="spring的工厂类"></a>spring的工厂类</h3><blockquote><ul><li><strong>BeanFactory</strong> with <strong>ApplicationContext</strong></li></ul></blockquote><ol><li><strong>BeanFactory 是早期spring提供的工厂类</strong></li><li><strong>ApplicationContext是目前版本提供的工厂类</strong></li><li>ApplicationContext的功能比BeanFactory功能多<ul><li><em>BeanFactory在调用getBean()方法时才会生成类的实例</em></li><li><em>ApplicationContext在加载spring配置文件的时候生成类的实例</em></li></ul></li></ol><blockquote><ul><li>ApplicationContext的实现类的区别</li></ul></blockquote><ol><li><strong>ClassPathXmlApplicationContext</strong><ol><li>加载的是类路径(src)下的spring配置文件</li></ol></li><li><em>FileSystemXMLApplicationContext</em><ol><li>加载的是文件系统下的配置文件(磁盘路径)</li></ol></li></ol><ul><li><strong>Question</strong></li></ul><ol><li>为什么不直接使用顶级接口对象来操作<ol><li>BeanFactory采用延迟加载，第一次getBean时才会初始化Bean</li><li>BeanFactory的用法：<ol><li>BeanFactory ac = new <del>XmlBeanFactory</del>(new CalssPathResource(“application.xml”));</li><li>BeanFactory ac = new <del>XmlBeanFactory</del>(new  FileSystemResource(“D:\applicationContext.xml”)); </li></ol></li><li>ApplicationContext是对BeanFactory扩展，提供更多地功能<ol><li>国际化处理</li><li>事件传递</li><li>Bean自动装配</li><li>各种不同应用层的Context的实现</li></ol></li></ol></li><li>由此可见，ApplicationContext 更加强大。so，现在开发基本没人用BeanFactory</li></ol><ul><li><em>show code</em></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSpring</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//构建spring工厂</span></span><br><span class="line">    <span class="comment">//ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");</span></span><br><span class="line">    <span class="comment">//使用BeanFactory</span></span><br><span class="line">    <span class="comment">//BeanFactory applicationContext = new XmlBeanFactory(new ClassPathResource("applicationContext.xml"));</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//直接使用超级接口</span></span><br><span class="line">    BeanFactory applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    IUserService userService=(IUserService) applicationContext.getBean(<span class="string">"userService"</span>);</span><br><span class="line">    userService.login();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spring相关配置"><a href="#spring相关配置" class="headerlink" title="spring相关配置"></a>spring相关配置</h3><ul><li><p>bean中 id 与 name 的配置</p><ul><li><em>id 中不能出现特殊字符</em></li><li><em>name中可以出现特殊字符</em><ul><li>name中可以指定多个标识符(第一个为标识符，其余的为别名，若指定了id，id则为标识符，name中的为别名)</li><li>name中的标识符可以使用 ‘,’  ‘;’  ‘ ‘(逗号，分号，空格)分隔开</li></ul></li></ul></li><li><p>bean的作用访问配置：<strong><em>scope的配置</em></strong></p><ul><li>spring创建类时，默认采用单例模式进行创建，如果想改变单例模式，需要通过scope属性设置</li><li>scope属性的取值：<ul><li>singleton : 默认值，单例</li><li>prototyep : 多例的</li><li>request、session、globalsession，分别是将创建的对象存到request、session、全局的session中</li></ul></li></ul></li><li><p>bean的生命周期配置</p><ul><li><p>创建Bean.java</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bean的构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bean被初始化了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bean被销毁了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>spring容器下bean中配置</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring的Bean的作用范围的配置============ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean1"</span> <span class="attr">class</span>=<span class="string">"com.itheima.spring.demo2.Bean1"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span> <span class="attr">init-method</span>=<span class="string">"setup"</span> <span class="attr">destroy-method</span>=<span class="string">"destroy"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span></span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>spring的分模块开发的配置</p><ul><li><p>在加载配置文件时，加载多个配置文件</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span>  ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>, <span class="string">"applicationContext2.xml"</span>);</span><br></pre></td></tr></table></figure></li><li><p>在配置文件中引入其他配置文件</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"applicationContext_2.xml"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Use the terminal to create Maven projects</title>
      <link href="/2018/07/19/Use-the-terminal-to-create-Maven-projects/"/>
      <url>/2018/07/19/Use-the-terminal-to-create-Maven-projects/</url>
      <content type="html"><![CDATA[<hr><a id="more"></a><h3 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h3><ul><li>mvn –v (mvn -version)</li></ul><p><img src="/images/mvn/path_1.png" alt="mav-version"></p><h3 id="maven创建java项目"><a href="#maven创建java项目" class="headerlink" title="maven创建java项目"></a>maven创建java项目</h3><ul><li>mvn archetype:generate -DgroupId=com.java_demo -DartifactId=java_demo</li></ul><h3 id="maven创建web项目"><a href="#maven创建web项目" class="headerlink" title="maven创建web项目"></a>maven创建web项目</h3><ul><li>mvn archetype:generate -DgroupId=com.web_demo -DartifactId=web_demo -DarchetypeArtifactId=maven-archetype-webapp<ul><li>archetype：原型插件</li><li>DgroupId：一般填写公司域名后缀倒过来</li><li>DartifactId：项目名</li><li>DarchetypeArtifactId：web项目的模板</li></ul></li><li>mvn archetype:create -DgroupId=com.web_demo -DartifactId=web_demo -DarchetypeArtifatId=maven-archetype-webapp<ul><li><strong><em>注意事项</em></strong>：3.5版本以上丢弃掉create方式创建maven项目，使用generate。所以上面一种是3.5以上的创建方式，这种是3.5以下的。</li></ul></li></ul><h3 id="创建和导入-IntelliJ-IDEA或Eclipse"><a href="#创建和导入-IntelliJ-IDEA或Eclipse" class="headerlink" title="创建和导入(IntelliJ IDEA或Eclipse)"></a>创建和导入(IntelliJ IDEA或Eclipse)</h3><ul><li>第一步：将创建项目命令复制到终端</li></ul><p><img src="/images/mvn/path_2.png" alt="2"></p><ul><li>第二步：执行第一步之后，中间若出现需要填什么直接回车，最后会出现BUILD SUCCESS则创建成功了</li></ul><p><img src="/images/mvn/path_3.png" alt="3"></p><ul><li>第三步：Import Project</li></ul><ol><li>Import Project<br><img src="/images/mvn/path_4.png" alt="4"></li><li>选择创建好的项目<br><img src="/images/mvn/path_4_1.png" alt="4-1"></li><li>下一步<br><img src="/images/mvn/path_4_2.png" alt="4-2"></li><li>选择jdk,然后next -&gt; finish<br><img src="/images/mvn/path_4_3.png" alt="4-3"></li><li>完成<br><img src="/images/mvn/path_5.png" alt="5"></li></ol>]]></content>
      
      <categories>
          
          <category> maven, Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Java </tag>
            
            <tag> maven </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>定时任务调度工具之Timer</title>
      <link href="/2018/07/18/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B7%A5%E5%85%B7%E4%B9%8BTimer/"/>
      <url>/2018/07/18/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B7%A5%E5%85%B7%E4%B9%8BTimer/</url>
      <content type="html"><![CDATA[<hr><a id="more"></a><h3 id="是什么是定时任务调度？"><a href="#是什么是定时任务调度？" class="headerlink" title="是什么是定时任务调度？"></a>是什么是定时任务调度？</h3><blockquote><p>  基于给定的时间点、给定的时间间隔或者给定的执行次数自动执行任务。<br>  Timer 由JDK自带提供！</p></blockquote><h3 id="Timer的定义"><a href="#Timer的定义" class="headerlink" title="Timer的定义"></a>Timer的定义</h3><blockquote><p>  有且仅有一个后台线程对多个业务线程进行定时定频率的调度</p></blockquote><h3 id="Timer定时调度任务的四种用法"><a href="#Timer定时调度任务的四种用法" class="headerlink" title="Timer定时调度任务的四种用法"></a>Timer定时调度任务的四种用法</h3><p><strong>首先，创建一个MyTimerTask类，继承TimerTask</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTimerTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTimerTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"current name is "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.<strong>schedule(task, time) : 在时间等于或者超过time的时候执行，且执行一次task。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Timer实例</span></span><br><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"><span class="comment">// 创建一个TimerTask实例</span></span><br><span class="line">MyTimerTask task = <span class="keyword">new</span> MyTimerTask(<span class="string">"s1"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在时间等于或者超过time的时候执行，且执行一次task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"><span class="comment">// 在当前时间的5秒后执行该任务</span></span><br><span class="line">calendar.add(Calendar.SECOND, <span class="number">5</span>);</span><br><span class="line">timer.schedule(task, calendar.getTime());</span><br></pre></td></tr></table></figure></p><p>2.<strong>schedule(task, time, period) : 在时间等于或者超过time的时候首次执行task，之后每隔period毫秒重复执行task</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Timer实例</span></span><br><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"><span class="comment">// 创建一个TimerTask实例</span></span><br><span class="line">MyTimerTask task = <span class="keyword">new</span> MyTimerTask(<span class="string">"s2"</span>);</span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在时间等于或者超过time的时候首次执行task，之后每隔period毫秒重复执行task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">timer.schedule(task, calendar.getTime(), <span class="number">3000</span>);</span><br></pre></td></tr></table></figure></p><p>3.<strong>schedule(task, delay) : 等待delay毫秒后执行且执行一次task</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Timer实例</span></span><br><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"><span class="comment">// 创建一个TimerTask实例</span></span><br><span class="line">MyTimerTask task = <span class="keyword">new</span> MyTimerTask(<span class="string">"s3"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待delay毫秒后执行且执行一次task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">timer.schedule(task, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure></p><p>4.<strong>schedule(task, delay, period) : 等待等于或者超过delay毫秒后首次执行task 之后每隔period毫秒重复执行task</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Timer实例</span></span><br><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"><span class="comment">// 创建一个TimerTask实例</span></span><br><span class="line">MyTimerTask task = <span class="keyword">new</span> MyTimerTask(<span class="string">"小米"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待delay毫秒后首次执行task 之后每隔period毫秒重复执行task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">timer.schedule(task, <span class="number">3000</span>, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure></p><h3 id="scheduleAtFixedRate的两种用法"><a href="#scheduleAtFixedRate的两种用法" class="headerlink" title="scheduleAtFixedRate的两种用法"></a>scheduleAtFixedRate的两种用法</h3><p>1.<strong>scheduleAtFixedRate(TimerTask task, Date firstTime, long period) : 时间等于或者超过time的时候首次执行task，之后每隔period毫秒重复执行task</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Timer实例</span></span><br><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"><span class="comment">// 创建一个TimerTask实例</span></span><br><span class="line">MyTimerTask task = <span class="keyword">new</span> MyTimerTask(<span class="string">"scheduleAtFixedRate1"</span>);</span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 时间等于或者超过time的时候首次执行task，之后每隔period毫秒重复执行task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">timer.scheduleAtFixedRate(task, calendar.getTime(), <span class="number">2000</span>);</span><br></pre></td></tr></table></figure></p><p>2.<strong>scheduleAtFixedRate(TimerTask task, long delay, long period):等待等于或者超过delay毫秒后首次执行task 之后每隔period毫秒重复执行task</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Timer实例</span></span><br><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"><span class="comment">// 创建一个TimerTask实例</span></span><br><span class="line">MyTimerTask task = <span class="keyword">new</span> MyTimerTask(<span class="string">"scheduleAtFixedRate2"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待等于或者超过delay毫秒后首次执行task 之后每隔period毫秒重复执行task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">timer.scheduleAtFixedRate(task, <span class="number">3000</span>, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure></p><h3 id="TimerTask其他函数介绍"><a href="#TimerTask其他函数介绍" class="headerlink" title="TimerTask其他函数介绍"></a>TimerTask其他函数介绍</h3><ul><li><p><strong>cancel() 取消当前TimerTask中的任务</strong></p></li><li><p><strong>scheduleExecutionTime() 返回此任务实际执行的已安排的执行时间</strong></p></li></ul><h3 id="Timer其他函数介绍"><a href="#Timer其他函数介绍" class="headerlink" title="Timer其他函数介绍"></a>Timer其他函数介绍</h3><ul><li><strong>cancel() 终止此定时器，丢弃所有当前已安排的任务</strong></li><li><strong>int purge() 从此计时器的任务队列中移除所有==已取消==的任务，返回值是从队列中移除的任务数</strong></li></ul>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Java </tag>
            
            <tag> Timer </tag>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>阿里云服务器搭建以及Linux安装软件小结</title>
      <link href="/2018/07/18/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8ALinux%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%B0%8F%E7%BB%93/"/>
      <url>/2018/07/18/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8ALinux%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<hr><a id="more"></a><h5 id="购买"><a href="#购买" class="headerlink" title="购买"></a>购买</h5><blockquote><p><strong>首先，在阿里云官网购买云服务器ESC</strong> (<a href="https://promotion.aliyun.com/ntms/campus2017.html?spm=5176.8142029.631162.75.68606d3e9rbcEa" target="_blank" rel="noopener">https://promotion.aliyun.com/ntms/campus2017.html?spm=5176.8142029.631162.75.68606d3e9rbcEa</a>) 。这个网址是学生优惠，非常划算！</p></blockquote><p><img src="https://toolife.github.io/images/ali_cloud/path_1.png" alt="path_1"></p><h5 id="配置密码"><a href="#配置密码" class="headerlink" title="配置密码"></a>配置密码</h5><blockquote><p><strong>配置连接(登录)服务器密码、设置远程连接密码</strong></p></blockquote><p><img src="https://toolife.github.io/images/ali_cloud/path_2.png" alt="path_2"></p><h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><blockquote><p>  <strong>购买好云服务器，设置好密码之后，再远程连接云服务器 ( 我服务器镜像是Linux Center OS 7.3 64位 )，点击远程连接，就跳转到了一个命令行窗口.</strong></p></blockquote><p><img src="https://toolife.github.io/images/ali_cloud/path_3.png" alt="path_3"></p><p><img src="https://toolife.github.io/images/ali_cloud/path_4.png" alt="path_4"></p><p>连接…..</p><p><img src="https://toolife.github.io/images/ali_cloud/path_6.png" alt="path_6"></p><ul><li>也可以通过<strong>SecureCRT</strong>客户端连接，或者<strong>本机终端连接</strong></li></ul><p><img src="https://toolife.github.io/images/ali_cloud/path_8.png" alt="SecureCRT客户端"></p><h5 id="推荐一个好用的插件：fish"><a href="#推荐一个好用的插件：fish" class="headerlink" title="推荐一个好用的插件：fish"></a>推荐一个好用的插件：fish</h5><blockquote><p>  优点：让你的命令行具有提示功能，还能记录你输入过得命令。缺点就是有些命令识别不了，需要退出fish模式下再执行😆</p></blockquote><p><img src="https://toolife.github.io/images/ali_cloud/path_7.png" alt="path_7"></p><h5 id="阿里云服务器防火墙与端口"><a href="#阿里云服务器防火墙与端口" class="headerlink" title="阿里云服务器防火墙与端口"></a>阿里云服务器防火墙与端口</h5><blockquote><p>  阿里云服务器信息</p><p>  Linux Center OS 7.3 x86_64</p><p>  <strong>前言，Center OS 7.0 以后默认使用的是firewall作为防火墙，而Center OS 7.0以前，使用 iptables 作为防火墙，所以我们在开启、关闭、刷新服务以及打开端口都变了，使用systemctl命令。systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体</strong></p></blockquote><p>1.firewalld的基本使用<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">启动: systemctl start firewalld</span><br><span class="line">关闭: systemctl stop firewalld</span><br><span class="line">查看状态: systemctl status firewalld </span><br><span class="line">开机禁用: systemctl disable firewalld</span><br><span class="line">开机启用: systemctl enable firewalld</span><br></pre></td></tr></table></figure></p><p>2.配置firewalld-cmd<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">查看版本: firewall-cmd --version</span><br><span class="line">查看帮助: firewall-cmd --help</span><br><span class="line">显示状态: firewall-cmd --state</span><br><span class="line">查看所有打开的端口: firewall-cmd --zone=public --list-ports</span><br><span class="line">更新防火墙规则: firewall-cmd --reload</span><br><span class="line">查看区域信息: firewall-cmd --get-active-zones</span><br><span class="line">查看指定接口所属区域: firewall-cmd --get-zone-of-interface=eth0</span><br><span class="line">拒绝所有包:firewall-cmd --panic-on</span><br><span class="line">取消拒绝状态: firewall-cmd --panic-off</span><br><span class="line">查看是否拒绝: firewall-cmd --query-panic</span><br></pre></td></tr></table></figure></p><p>3.systemctl命令介绍<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">启动一个服务：systemctl start firewalld.service</span><br><span class="line">关闭一个服务：systemctl stop firewalld.service</span><br><span class="line">重启一个服务：systemctl restart firewalld.service</span><br><span class="line">显示一个服务的状态：systemctl status firewalld.service</span><br><span class="line">在开机时启用一个服务：systemctl enable firewalld.service</span><br><span class="line">在开机时禁用一个服务：systemctl disable firewalld.service</span><br><span class="line">查看服务是否开机启动：systemctl is-enabled firewalld.service</span><br><span class="line">查看已启动的服务列表：systemctl list-unit-files|grep enabled</span><br><span class="line">查看启动失败的服务列表：systemctl --failed</span><br></pre></td></tr></table></figure></p><p>4.开启、查看、关闭端口<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开放<span class="number">80</span>端口：firewall-cmd --zone=public --add-port=<span class="number">80</span>/tcp --permanent</span><br><span class="line">查看<span class="number">80</span>端口是否开放：firewall-cmd --zone= public --query-port=<span class="number">80</span>/tcp</span><br><span class="line">关闭<span class="number">80</span>端口：firewall-cmd --zone= public --remove-port=<span class="number">80</span>/tcp --permanent</span><br><span class="line">重新载入：firewall-cmd --reload</span><br></pre></td></tr></table></figure></p><p>5.既然端口已经打开了，然而还是访问不了！！！<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://x.x.x.x:80</span></span><br></pre></td></tr></table></figure></p><p>6.在阿里云本实例安全组中，添加安全组规则<br><img src="https://toolife.github.io/images/ali_cloud/path_9.png" alt="path_9"></p><p>7.再次访问还是访问不了，原因是：缺少Apache服务，接下来安装<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">安装：yum install httpd httpd-devel</span><br><span class="line">设置开机自启：chkconfig --levels <span class="number">235</span> httpd on</span><br><span class="line">开启Apache服务：systemctl start httpd</span><br><span class="line"></span><br><span class="line">再次访问 http://x.x.x.x:<span class="number">80</span>，ok了</span><br></pre></td></tr></table></figure></p><p><img src="https://toolife.github.io/images/ali_cloud/path_10.png" alt="path_10"></p><h5 id="安装JDK、Tomcat"><a href="#安装JDK、Tomcat" class="headerlink" title="安装JDK、Tomcat"></a>安装JDK、Tomcat</h5><blockquote><p>  <strong>安装前言，在阿里云服务器安装JDK、Tomcat的一系列Bug。在我个人的本机上使用的是Center OS 6.4 ，这里使用的是iptables作为防火墙。但安装程序都是一样的，期间肯定会出现Bug。come on，一步一步来安装JDK与Tomcat。</strong></p></blockquote><h6 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h6><p>1.先准备好Linux下JDK安装包 (jdk-8u171-linux-i586.tar)<br>2.检查系统上是否安装了jdk(若安装了就需要先卸载再使用我们自己的)<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure></p><p>3.查看出安装的java的软件包<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep java</span><br></pre></td></tr></table></figure></p><p>4.卸载jdk<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps java-1.6.0-openjdk-1.6.0.0-1.66.1.13.0.el6.i686</span><br><span class="line">rpm -e --nodeps java-1.7.0-openjdk-1.7.0.45-2.4.3.3.el6.i686 tzdata-java-2013g-1.el6.noarch</span><br></pre></td></tr></table></figure></p><p>5.在 /usr/local 新建一个文件夹 java,存放jdk<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/java</span><br></pre></td></tr></table></figure></p><p>6.移动 jdk-8u171-linux-i586.tar 到 /usr/local/java下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv jdk-8u171-linux-i586.tar /usr/local/java</span><br></pre></td></tr></table></figure></p><p>7.进入 /usr/local/java 目录,解压jdk到当前目录<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/java</span><br><span class="line">tar -xvf jdk-8u171-linux-i586.tar</span><br></pre></td></tr></table></figure></p><p>8.配置环境变量<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line">   </span><br><span class="line"><span class="meta">#</span> 在文件的最后面添加如下代码</span><br><span class="line">export JAVA_HOME=/usr/local/java/jdk1.7.0_72</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure></p><p>9.保存退出<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 在vim下，按shift + : 调出底部命令，输入wq (保存退出)，回车ok</span><br></pre></td></tr></table></figure></p><p>10.重新加载配置文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></p><p>11.查看jdk是否安装成功<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br><span class="line">[root@jason ~]# -bash: /usr/java/jdk1.7.0_71/bin/java: /lib/ld-linux.so.2: bad ELF interpreter: No such file or directory</span><br></pre></td></tr></table></figure></p><blockquote><p>  <strong>问题来了，出现了错误：No such file or directory。</strong></p><p>  <strong>原因：没有那个文件或目录，需要安装glibc</strong></p></blockquote><p>12.终端输入下面的命令，安装好glibc，问题解决,，再次查看jdk版本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install glibc.i686</span><br><span class="line">[root@jason ~]# java -version</span><br><span class="line">java version "1.8.0_171"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_171-b11)</span><br><span class="line">Java HotSpot(TM) Client VM (build 25.171-b11, mixed mode)</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>jdk安装完成！</strong></p></blockquote><h6 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h6><p>1.先准备好apache-tomcat安装包 (apache-tomcat-7.0.52.tar.gz)<br>2.在 /usr/local 新建一个文件夹tomcat<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/tomcat</span><br></pre></td></tr></table></figure></p><p>3.移动 apache-tomcat…tar.gz 到 /usr/local/tomcat<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv apache-tomcat-7.0.52.tar.gz /usr/local/tomcat/</span><br></pre></td></tr></table></figure></p><p>4.进入/usr/local/tomcat目录,解压Tomcat<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/tomcat</span><br><span class="line">tar -zxvf apache-tomcat-7.0.52.tar.gz</span><br></pre></td></tr></table></figure></p><p>5.进入 /usr/local/tomcat/apache-tomcat-7.0.52/bin<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/tomcat/apache-tomcat-7.0.52/bin</span><br></pre></td></tr></table></figure></p><p>6.启动tomcat(执行startup.sh文件)<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方式1:</span><br><span class="line">    sh startup.sh</span><br><span class="line">方式2:</span><br><span class="line">    ./startup.sh</span><br></pre></td></tr></table></figure></p><p>7.修改防火墙的规则，放行8080端口，同时在阿里云安全组规则中添加8080端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --add-port=8080/tcp --permanent</span><br></pre></td></tr></table></figure></p><p>8.查看服务器已开启的tcp端口<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@jason] # netstat -ntlp</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class="line">tcp        0      0 0.0.0.0:8009            0.0.0.0:*               LISTEN      3833/java</span><br><span class="line">tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      3833/java</span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      739/httpd</span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      2101/sshd</span><br><span class="line">tcp        0      0 127.0.0.1:8005          0.0.0.0:*               LISTEN      3833/java</span><br></pre></td></tr></table></figure></p><p>9.访问8080端口<br> <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://x.x.x.x:8080</span></span><br></pre></td></tr></table></figure></p><p><img src="https://toolife.github.io/images/ali_cloud/path_11.png" alt="path_11"></p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Linux </tag>
            
            <tag> Center OS </tag>
            
            <tag> 云服务器 </tag>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
