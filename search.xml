<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Use the terminal to create Maven projects</title>
      <link href="/2018/07/19/Use-the-terminal-to-create-Maven-projects/"/>
      <url>/2018/07/19/Use-the-terminal-to-create-Maven-projects/</url>
      <content type="html"><![CDATA[<hr><a id="more"></a><h4 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h4><ul><li>mvn –v (mvn -version)</li></ul><p><img src="/Users/honeyrr/Desktop/Demo/image/mav-version.png" alt="mav-version"></p><h4 id="maven创建java项目"><a href="#maven创建java项目" class="headerlink" title="maven创建java项目"></a>maven创建java项目</h4><ul><li>mvn archetype:generate -DgroupId=com.java_demo -DartifactId=java_demo</li></ul><h4 id="maven创建web项目"><a href="#maven创建web项目" class="headerlink" title="maven创建web项目"></a>maven创建web项目</h4><ul><li>mvn archetype:generate -DgroupId=com.web_demo -DartifactId=web_demo -DarchetypeArtifactId=maven-archetype-webapp<ul><li>archetype：原型插件</li><li>DgroupId：一般填写公司域名后缀倒过来</li><li>DartifactId：项目名</li><li>DarchetypeArtifactId：web项目的模板</li></ul></li><li>mvn archetype:create -DgroupId=com.web_demo -DartifactId=web_demo -DarchetypeArtifatId=maven-archetype-webapp<ul><li><strong><em>注意事项</em></strong>：3.5版本以上丢弃掉create方式创建maven项目，使用generate。所以上面一种是3.5以上的创建方式，这种是3.5以下的。</li></ul></li></ul><h4 id="项目创建好之后，将项目导入到IntelliJ-IDEA中"><a href="#项目创建好之后，将项目导入到IntelliJ-IDEA中" class="headerlink" title="项目创建好之后，将项目导入到IntelliJ IDEA中"></a>项目创建好之后，将项目导入到IntelliJ IDEA中</h4><ul><li>第一步：将创建项目命令复制到终端</li></ul><p><img src="/Users/honeyrr/Desktop/Demo/image/1.png" alt="1"></p><ul><li>第二步：执行第一步之后，中间若出现需要填什么直接回车，最后会出现BUILD SUCCESS则创建成功了</li></ul><p><img src="/Users/honeyrr/Desktop/Demo/image/2.png" alt="2"></p><ul><li>第三步：Import Project</li></ul><p><img src="/Users/honeyrr/Desktop/Demo/image/3.png" alt="3"></p><p><img src="/Users/honeyrr/Desktop/Demo/image/3-1.png" alt="3-1"></p><p><img src="/Users/honeyrr/Desktop/Demo/image/3-2.png" alt="3-2"></p><p><img src="/Users/honeyrr/Desktop/Demo/image/3-3.png" alt="3-3"></p><p><img src="/Users/honeyrr/Desktop/Demo/image/4.png" alt="4"></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>定时任务调度工具之Timer</title>
      <link href="/2018/07/18/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B7%A5%E5%85%B7%E4%B9%8BTimer/"/>
      <url>/2018/07/18/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B7%A5%E5%85%B7%E4%B9%8BTimer/</url>
      <content type="html"><![CDATA[<hr><a id="more"></a><h3 id="是什么是定时任务调度？"><a href="#是什么是定时任务调度？" class="headerlink" title="是什么是定时任务调度？"></a>是什么是定时任务调度？</h3><blockquote><p>  基于给定的时间点、给定的时间间隔或者给定的执行次数自动执行任务。<br>  Timer 由JDK自带提供！</p></blockquote><h3 id="Timer的定义"><a href="#Timer的定义" class="headerlink" title="Timer的定义"></a>Timer的定义</h3><blockquote><p>  有且仅有一个后台线程对多个业务线程进行定时定频率的调度</p></blockquote><h3 id="Timer定时调度任务的四种用法"><a href="#Timer定时调度任务的四种用法" class="headerlink" title="Timer定时调度任务的四种用法"></a>Timer定时调度任务的四种用法</h3><p><strong>首先，创建一个MyTimerTask类，继承TimerTask</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTimerTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTimerTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"current name is "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.<strong>schedule(task, time) : 在时间等于或者超过time的时候执行，且执行一次task。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Timer实例</span></span><br><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"><span class="comment">// 创建一个TimerTask实例</span></span><br><span class="line">MyTimerTask task = <span class="keyword">new</span> MyTimerTask(<span class="string">"s1"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在时间等于或者超过time的时候执行，且执行一次task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"><span class="comment">// 在当前时间的5秒后执行该任务</span></span><br><span class="line">calendar.add(Calendar.SECOND, <span class="number">5</span>);</span><br><span class="line">timer.schedule(task, calendar.getTime());</span><br></pre></td></tr></table></figure></p><p>2.<strong>schedule(task, time, period) : 在时间等于或者超过time的时候首次执行task，之后每隔period毫秒重复执行task</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Timer实例</span></span><br><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"><span class="comment">// 创建一个TimerTask实例</span></span><br><span class="line">MyTimerTask task = <span class="keyword">new</span> MyTimerTask(<span class="string">"s2"</span>);</span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在时间等于或者超过time的时候首次执行task，之后每隔period毫秒重复执行task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">timer.schedule(task, calendar.getTime(), <span class="number">3000</span>);</span><br></pre></td></tr></table></figure></p><p>3.<strong>schedule(task, delay) : 等待delay毫秒后执行且执行一次task</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Timer实例</span></span><br><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"><span class="comment">// 创建一个TimerTask实例</span></span><br><span class="line">MyTimerTask task = <span class="keyword">new</span> MyTimerTask(<span class="string">"s3"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待delay毫秒后执行且执行一次task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">timer.schedule(task, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure></p><p>4.<strong>schedule(task, delay, period) : 等待等于或者超过delay毫秒后首次执行task 之后每隔period毫秒重复执行task</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Timer实例</span></span><br><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"><span class="comment">// 创建一个TimerTask实例</span></span><br><span class="line">MyTimerTask task = <span class="keyword">new</span> MyTimerTask(<span class="string">"小米"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待delay毫秒后首次执行task 之后每隔period毫秒重复执行task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">timer.schedule(task, <span class="number">3000</span>, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure></p><h3 id="scheduleAtFixedRate的两种用法"><a href="#scheduleAtFixedRate的两种用法" class="headerlink" title="scheduleAtFixedRate的两种用法"></a>scheduleAtFixedRate的两种用法</h3><p>1.<strong>scheduleAtFixedRate(TimerTask task, Date firstTime, long period) : 时间等于或者超过time的时候首次执行task，之后每隔period毫秒重复执行task</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Timer实例</span></span><br><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"><span class="comment">// 创建一个TimerTask实例</span></span><br><span class="line">MyTimerTask task = <span class="keyword">new</span> MyTimerTask(<span class="string">"scheduleAtFixedRate1"</span>);</span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 时间等于或者超过time的时候首次执行task，之后每隔period毫秒重复执行task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">timer.scheduleAtFixedRate(task, calendar.getTime(), <span class="number">2000</span>);</span><br></pre></td></tr></table></figure></p><p>2.<strong>scheduleAtFixedRate(TimerTask task, long delay, long period):等待等于或者超过delay毫秒后首次执行task 之后每隔period毫秒重复执行task</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Timer实例</span></span><br><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"><span class="comment">// 创建一个TimerTask实例</span></span><br><span class="line">MyTimerTask task = <span class="keyword">new</span> MyTimerTask(<span class="string">"scheduleAtFixedRate2"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待等于或者超过delay毫秒后首次执行task 之后每隔period毫秒重复执行task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">timer.scheduleAtFixedRate(task, <span class="number">3000</span>, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure></p><h3 id="TimerTask其他函数介绍"><a href="#TimerTask其他函数介绍" class="headerlink" title="TimerTask其他函数介绍"></a>TimerTask其他函数介绍</h3><ul><li><p><strong>cancel() 取消当前TimerTask中的任务</strong></p></li><li><p><strong>scheduleExecutionTime() 返回此任务实际执行的已安排的执行时间</strong></p></li></ul><h3 id="Timer其他函数介绍"><a href="#Timer其他函数介绍" class="headerlink" title="Timer其他函数介绍"></a>Timer其他函数介绍</h3><ul><li><strong>cancel() 终止此定时器，丢弃所有当前已安排的任务</strong></li><li><strong>int purge() 从此计时器的任务队列中移除所有==已取消==的任务，返回值是从队列中移除的任务数</strong></li></ul>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> java </tag>
            
            <tag> Timer </tag>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>阿里云服务器搭建以及Linux安装软件小结</title>
      <link href="/2018/07/18/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8ALinux%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%B0%8F%E7%BB%93/"/>
      <url>/2018/07/18/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8ALinux%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<hr><a id="more"></a><h5 id="购买"><a href="#购买" class="headerlink" title="购买"></a>购买</h5><blockquote><p><strong>首先，在阿里云官网购买云服务器ESC</strong> (<a href="https://promotion.aliyun.com/ntms/campus2017.html?spm=5176.8142029.631162.75.68606d3e9rbcEa" target="_blank" rel="noopener">https://promotion.aliyun.com/ntms/campus2017.html?spm=5176.8142029.631162.75.68606d3e9rbcEa</a>) 。这个网址是学生优惠，非常划算！</p></blockquote><p><img src="https://toolife.github.io/images/ali_cloud/path_1.png" alt="path_1"></p><h5 id="配置密码"><a href="#配置密码" class="headerlink" title="配置密码"></a>配置密码</h5><blockquote><p><strong>配置连接(登录)服务器密码、设置远程连接密码</strong></p></blockquote><p><img src="https://toolife.github.io/images/ali_cloud/path_2.png" alt="path_2"></p><h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><blockquote><p>  <strong>购买好云服务器，设置好密码之后，再远程连接云服务器 ( 我服务器镜像是Linux Center OS 7.3 64位 )，点击远程连接，就跳转到了一个命令行窗口.</strong></p></blockquote><p><img src="https://toolife.github.io/images/ali_cloud/path_3.png" alt="path_3"></p><p><img src="https://toolife.github.io/images/ali_cloud/path_4.png" alt="path_4"></p><p>连接…..</p><p><img src="https://toolife.github.io/images/ali_cloud/path_6.png" alt="path_6"></p><ul><li>也可以通过<strong>SecureCRT</strong>客户端连接，或者<strong>本机终端连接</strong></li></ul><p><img src="https://toolife.github.io/images/ali_cloud/path_8.png" alt="SecureCRT客户端"></p><h5 id="推荐一个好用的插件：fish"><a href="#推荐一个好用的插件：fish" class="headerlink" title="推荐一个好用的插件：fish"></a>推荐一个好用的插件：fish</h5><blockquote><p>  优点：让你的命令行具有提示功能，还能记录你输入过得命令。缺点就是有些命令识别不了，需要退出fish模式下再执行😆</p></blockquote><p><img src="https://toolife.github.io/images/ali_cloud/path_7.png" alt="path_7"></p><h5 id="阿里云服务器防火墙与端口"><a href="#阿里云服务器防火墙与端口" class="headerlink" title="阿里云服务器防火墙与端口"></a>阿里云服务器防火墙与端口</h5><blockquote><p>  阿里云服务器信息</p><p>  Linux Center OS 7.3 x86_64</p><p>  <strong>前言，Center OS 7.0 以后默认使用的是firewall作为防火墙，而Center OS 7.0以前，使用 iptables 作为防火墙，所以我们在开启、关闭、刷新服务以及打开端口都变了，使用systemctl命令。systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体</strong></p></blockquote><p>1.firewalld的基本使用<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">启动: systemctl start firewalld</span><br><span class="line">关闭: systemctl stop firewalld</span><br><span class="line">查看状态: systemctl status firewalld </span><br><span class="line">开机禁用: systemctl disable firewalld</span><br><span class="line">开机启用: systemctl enable firewalld</span><br></pre></td></tr></table></figure></p><p>2.配置firewalld-cmd<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">查看版本: firewall-cmd --version</span><br><span class="line">查看帮助: firewall-cmd --help</span><br><span class="line">显示状态: firewall-cmd --state</span><br><span class="line">查看所有打开的端口: firewall-cmd --zone=public --list-ports</span><br><span class="line">更新防火墙规则: firewall-cmd --reload</span><br><span class="line">查看区域信息: firewall-cmd --get-active-zones</span><br><span class="line">查看指定接口所属区域: firewall-cmd --get-zone-of-interface=eth0</span><br><span class="line">拒绝所有包:firewall-cmd --panic-on</span><br><span class="line">取消拒绝状态: firewall-cmd --panic-off</span><br><span class="line">查看是否拒绝: firewall-cmd --query-panic</span><br></pre></td></tr></table></figure></p><p>3.systemctl命令介绍<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">启动一个服务：systemctl start firewalld.service</span><br><span class="line">关闭一个服务：systemctl stop firewalld.service</span><br><span class="line">重启一个服务：systemctl restart firewalld.service</span><br><span class="line">显示一个服务的状态：systemctl status firewalld.service</span><br><span class="line">在开机时启用一个服务：systemctl enable firewalld.service</span><br><span class="line">在开机时禁用一个服务：systemctl disable firewalld.service</span><br><span class="line">查看服务是否开机启动：systemctl is-enabled firewalld.service</span><br><span class="line">查看已启动的服务列表：systemctl list-unit-files|grep enabled</span><br><span class="line">查看启动失败的服务列表：systemctl --failed</span><br></pre></td></tr></table></figure></p><p>4.开启、查看、关闭端口<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开放<span class="number">80</span>端口：firewall-cmd --zone=public --add-port=<span class="number">80</span>/tcp --permanent</span><br><span class="line">查看<span class="number">80</span>端口是否开放：firewall-cmd --zone= public --query-port=<span class="number">80</span>/tcp</span><br><span class="line">关闭<span class="number">80</span>端口：firewall-cmd --zone= public --remove-port=<span class="number">80</span>/tcp --permanent</span><br><span class="line">重新载入：firewall-cmd --reload</span><br></pre></td></tr></table></figure></p><p>5.既然端口已经打开了，然而还是访问不了！！！<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://x.x.x.x:80</span></span><br></pre></td></tr></table></figure></p><p>6.在阿里云本实例安全组中，添加安全组规则<br><img src="https://toolife.github.io/images/ali_cloud/path_9.png" alt="path_9"></p><p>7.再次访问还是访问不了，原因是：缺少Apache服务，接下来安装<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">安装：yum install httpd httpd-devel</span><br><span class="line">设置开机自启：chkconfig --levels <span class="number">235</span> httpd on</span><br><span class="line">开启Apache服务：systemctl start httpd</span><br><span class="line"></span><br><span class="line">再次访问 http://x.x.x.x:<span class="number">80</span>，ok了</span><br></pre></td></tr></table></figure></p><p><img src="https://toolife.github.io/images/ali_cloud/path_10.png" alt="path_10"></p><h5 id="安装JDK、Tomcat"><a href="#安装JDK、Tomcat" class="headerlink" title="安装JDK、Tomcat"></a>安装JDK、Tomcat</h5><blockquote><p>  <strong>安装前言，在阿里云服务器安装JDK、Tomcat的一系列Bug。在我个人的本机上使用的是Center OS 6.4 ，这里使用的是iptables作为防火墙。但安装程序都是一样的，期间肯定会出现Bug。come on，一步一步来安装JDK与Tomcat。</strong></p></blockquote><h6 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h6><p>1.先准备好Linux下JDK安装包 (jdk-8u171-linux-i586.tar)<br>2.检查系统上是否安装了jdk(若安装了就需要先卸载再使用我们自己的)<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure></p><p>3.查看出安装的java的软件包<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep java</span><br></pre></td></tr></table></figure></p><p>4.卸载jdk<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps java-1.6.0-openjdk-1.6.0.0-1.66.1.13.0.el6.i686</span><br><span class="line">rpm -e --nodeps java-1.7.0-openjdk-1.7.0.45-2.4.3.3.el6.i686 tzdata-java-2013g-1.el6.noarch</span><br></pre></td></tr></table></figure></p><p>5.在 /usr/local 新建一个文件夹 java,存放jdk<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/java</span><br></pre></td></tr></table></figure></p><p>6.移动 jdk-8u171-linux-i586.tar 到 /usr/local/java下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv jdk-8u171-linux-i586.tar /usr/local/java</span><br></pre></td></tr></table></figure></p><p>7.进入 /usr/local/java 目录,解压jdk到当前目录<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/java</span><br><span class="line">tar -xvf jdk-8u171-linux-i586.tar</span><br></pre></td></tr></table></figure></p><p>8.配置环境变量<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line">   </span><br><span class="line"><span class="meta">#</span> 在文件的最后面添加如下代码</span><br><span class="line">export JAVA_HOME=/usr/local/java/jdk1.7.0_72</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure></p><p>9.保存退出<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 在vim下，按shift + : 调出底部命令，输入wq (保存退出)，回车ok</span><br></pre></td></tr></table></figure></p><p>10.重新加载配置文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></p><p>11.查看jdk是否安装成功<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br><span class="line">[root@jason ~]# -bash: /usr/java/jdk1.7.0_71/bin/java: /lib/ld-linux.so.2: bad ELF interpreter: No such file or directory</span><br></pre></td></tr></table></figure></p><blockquote><p>  <strong>问题来了，出现了错误：No such file or directory。</strong></p><p>  <strong>原因：没有那个文件或目录，需要安装glibc</strong></p></blockquote><p>12.终端输入下面的命令，安装好glibc，问题解决,，再次查看jdk版本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install glibc.i686</span><br><span class="line">[root@jason ~]# java -version</span><br><span class="line">java version "1.8.0_171"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_171-b11)</span><br><span class="line">Java HotSpot(TM) Client VM (build 25.171-b11, mixed mode)</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>jdk安装完成！</strong></p></blockquote><h6 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h6><p>1.先准备好apache-tomcat安装包 (apache-tomcat-7.0.52.tar.gz)<br>2.在 /usr/local 新建一个文件夹tomcat<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/tomcat</span><br></pre></td></tr></table></figure></p><p>3.移动 apache-tomcat…tar.gz 到 /usr/local/tomcat<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv apache-tomcat-7.0.52.tar.gz /usr/local/tomcat/</span><br></pre></td></tr></table></figure></p><p>4.进入/usr/local/tomcat目录,解压Tomcat<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/tomcat</span><br><span class="line">tar -zxvf apache-tomcat-7.0.52.tar.gz</span><br></pre></td></tr></table></figure></p><p>5.进入 /usr/local/tomcat/apache-tomcat-7.0.52/bin<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/tomcat/apache-tomcat-7.0.52/bin</span><br></pre></td></tr></table></figure></p><p>6.启动tomcat(执行startup.sh文件)<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方式1:</span><br><span class="line">    sh startup.sh</span><br><span class="line">方式2:</span><br><span class="line">    ./startup.sh</span><br></pre></td></tr></table></figure></p><p>7.修改防火墙的规则，放行8080端口，同时在阿里云安全组规则中添加8080端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --add-port=8080/tcp --permanent</span><br></pre></td></tr></table></figure></p><p>8.查看服务器已开启的tcp端口<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@jason] # netstat -ntlp</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class="line">tcp        0      0 0.0.0.0:8009            0.0.0.0:*               LISTEN      3833/java</span><br><span class="line">tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      3833/java</span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      739/httpd</span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      2101/sshd</span><br><span class="line">tcp        0      0 127.0.0.1:8005          0.0.0.0:*               LISTEN      3833/java</span><br></pre></td></tr></table></figure></p><p>9.访问8080端口<br> <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://x.x.x.x:8080</span></span><br></pre></td></tr></table></figure></p><p><img src="https://toolife.github.io/images/ali_cloud/path_11.png" alt="path_11"></p>]]></content>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Linux </tag>
            
            <tag> Center OS </tag>
            
            <tag> 云服务器 </tag>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
