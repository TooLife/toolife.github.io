<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Java关键字爬坑之‘static’</title>
      <link href="/2018/09/06/Java%E5%85%B3%E9%94%AE%E5%AD%97%E7%88%AC%E5%9D%91%E4%B9%8B%E2%80%98static%E2%80%99/"/>
      <url>/2018/09/06/Java%E5%85%B3%E9%94%AE%E5%AD%97%E7%88%AC%E5%9D%91%E4%B9%8B%E2%80%98static%E2%80%99/</url>
      <content type="html"><![CDATA[<hr><a id="more"></a><blockquote><p>序言：近期朋友提到了一个有关于static关键字一个坑，今天把它总结一下，希望能给读者解惑。在阅读之前请先对static不同使用场景的概念有所了解。</p></blockquote><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test t1 = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"blockA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"blockB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test t2 = <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题：以上代码的打印结果是什么？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blockA</span><br><span class="line">blockB</span><br><span class="line">blockA</span><br></pre></td></tr></table></figure><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><blockquote><p>根据我个人的理解一个代码块被加载的顺序是：静态代码块‘优先于’代码块，而以上的打印却反之。<br>通过查看编译后的字节码文件如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test t1 = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"blockA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"blockB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由此可见，普通的代码块直接被编译到了无参构造器中。<br>现在的分析是：在实例化一个Test静态对象时，先走了构造函数，再走静态代码块，所以打印blockA、blockB。而在函数中又实例化一个Test对象(这时类已经被加载一次，也就是说static修饰的成员变量，静态代码块等等之后被加载一次)，所以在打印一个blockA。<br>以上的解释似乎能走通，但是存在疑问：</p></blockquote><ul><li>根据类加载的执行顺序，静态修饰的都要先走，非静态后走，现在的解释相反！现在又猜想构造器是静态的？<ul><li>如果是静态的就违背了Java语言规范</li><li>静态方法里面是不可以使用this，而构造函数可以使用this</li><li>静态方法是不可以重写的，构造方法确实不可以重写</li></ul></li></ul><blockquote><p>带着疑问我翻阅了Java编程思想和bing了许多资料。在Java编程思想中的第n页，根据书的作者所说Java的构造函数可以看出静态的；当然网上也有很多反例，比如：通过jvm底层去研究。看了这么多，个人总结为：构造函数不是静态的也不是非静态的，就象正负数与0一样。</p></blockquote>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JWT单点登录</title>
      <link href="/2018/08/28/JWT%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
      <url>/2018/08/28/JWT%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
      <content type="html"><![CDATA[<hr><a id="more"></a><blockquote><p>撰写中…</p></blockquote>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JWT </tag>
            
            <tag> SSO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Boot初探</title>
      <link href="/2018/08/20/Spring-Boot%E5%88%9D%E6%8E%A2/"/>
      <url>/2018/08/20/Spring-Boot%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<hr><a id="more"></a><blockquote><p>本文介绍Spring Boot入门Demo，以及一些常用配置</p></blockquote><h3 id="什么是Spring-Boot？"><a href="#什么是Spring-Boot？" class="headerlink" title="什么是Spring Boot？"></a>什么是Spring Boot？</h3><ul><li>随着动态语言的流行(Ruby、 Groovy、 Scala、 Node.js), Java的开发显得格外的笨重:繁<br>多的配置、低下的开发效率、复杂的部署流程以及第三方技术集成难度大。</li><li>在上述环境下，Spring Boot应运而生。它使用“习惯优于配置”(项目中存在大量的配置，<br>此外还内置-一个习惯性的配置，让你无须手动进行配置)的理念让你的项目快速运行起来。使<br>用SpringBoot很容易创建一个独立运行(运行jar,内嵌Servlet容器)、准生产级别的基于Spring<br>框架的项目，使用Spring Boot你可以不用或者只需要很少的Spring配置。 ——Spring Boot颠覆者</li></ul><h3 id="Spring-Boot优缺点"><a href="#Spring-Boot优缺点" class="headerlink" title="Spring Boot优缺点"></a>Spring Boot优缺点</h3><ul><li>优点：<ul><li>快速构建项目</li><li>对主流开发框架无配置集成(SSM、Dubbox….)</li><li>项目可独立运行，无需依赖外部servlet容器(因为内嵌Servlet容器)</li><li>提供运行时应用监控(http、ssh…)</li><li>极大的提高开发、部署效率</li><li>与云计算天然集成</li></ul></li><li>缺点：<ul><li>待更新…</li></ul></li></ul><h3 id="快速搭建Spring-Boot项目"><a href="#快速搭建Spring-Boot项目" class="headerlink" title="快速搭建Spring Boot项目"></a>快速搭建Spring Boot项目</h3><blockquote><p>IDE使用Intellij IDEA、JDK 1.8、使用Maven作为项目的构建方式、部署形式以jar包形式</p></blockquote><ol><li>使用IDEA Create New Project</li><li>选择Spring Initializr</li><li>设置Project的元数据(Metadata)</li><li>必须在有网的条件下：选择项目选用的技术，这里我们选web下的web</li><li>然后Finish</li></ol><blockquote><p>之后会出现如下界面：</p></blockquote><p><img src="/images/springboot/new.png" alt="初始化"></p><ul><li><p>项目结构分析</p><ul><li>在java文件下会出现一个DemoApplication类，这个就是启动项目的类，运行main方法即可</li><li>在resources下会有两个文件夹，一个文件<ul><li>static存放静态文件，比如CSS、JS…</li><li>templates也是存放一些静态资源，比如HTML文件…</li><li>application.properties这个就是配置文件，项目的一些配置都可以写在这里</li></ul></li></ul></li><li><p>运行main方法，浏览器访问<a href="http://localhost:8080/,出现如下界面即spring" target="_blank" rel="noopener">http://localhost:8080/,出现如下界面即spring</a> boot简单demo搭建成功<br><img src="/images/springboot/page.png" alt="初始化"></p></li></ul><h3 id="访问页面（HTML）"><a href="#访问页面（HTML）" class="headerlink" title="访问页面（HTML）"></a>访问页面（HTML）</h3><blockquote><p><strong> Spring Boot默认将/</strong> 所有访问映射到以下目录 **</p></blockquote><ul><li>classpath:/static</li><li>classpath:/public</li><li>classpath:/resources</li><li>classpath:/META-INF/resources (war包下)</li></ul><blockquote><p>所以我们可以将访问的资源放到以上文件夹中，若创建的新项目没有对应文件夹，直接创建即可！</p></blockquote><p><img src="/images/springboot/web_page.png" alt="初始化"></p><blockquote><p>重新运行，再访问静态资源<a href="http://localhost:8080/world.html" target="_blank" rel="noopener">http://localhost:8080/world.html</a></p></blockquote><p><img src="/images/springboot/web_page1.png" alt="初始化"></p><h3 id="访问URL"><a href="#访问URL" class="headerlink" title="访问URL"></a>访问URL</h3><blockquote><p>新建一个package为controller，再创建一个HelloController类,如下</p></blockquote><p><img src="/images/springboot/controller.png" alt="初始化"></p><blockquote><p>重新运行，再访问<a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a></p></blockquote><p><img src="/images/springboot/hello.png" alt="初始化"></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><blockquote><p>先看图</p></blockquote><ul><li><p>application.properties<br><img src="/images/springboot/properties.png" alt="初始化"></p></li><li><p>application.yml<br><img src="/images/springboot/yml.png" alt="初始化"></p></li></ul><blockquote><p>Spring Boot 配置文件可以通过两种方式配置，如上。经过以上对比，第二种是不是看起来更有层次感.<br>Spring Boot简单Demo就到这里😆</p></blockquote>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git命令详细使用</title>
      <link href="/2018/08/18/Git%E5%91%BD%E4%BB%A4%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/08/18/Git%E5%91%BD%E4%BB%A4%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<hr><a id="more"></a><blockquote><p>序言：目前，Git是最流行的版本控制系统。相比于SVN，我更偏爱Git! 本文将详细介绍Git的使用。</p></blockquote><h3 id="什么是Git"><a href="#什么是Git" class="headerlink" title="什么是Git?"></a>什么是Git?</h3><blockquote><p>Git是一种分布式版本控制系统（DVCS），也称为分散式。每个开发人员都拥有存储库的完整副本，该存储库位于云中(远程仓库)。</p></blockquote><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><blockquote><p>本人使用的是Mac，终端自带Git工具</p></blockquote><ul><li><p>Mac:通过Homebrew安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 安装homebrew</span><br><span class="line">/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span><br><span class="line"><span class="meta">#</span> 安装Git</span><br><span class="line">brew install git</span><br></pre></td></tr></table></figure></li><li><p>Linux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用Git"><a href="#使用Git" class="headerlink" title="使用Git"></a>使用Git</h3><h4 id="创建本地存储库"><a href="#创建本地存储库" class="headerlink" title="创建本地存储库"></a>创建本地存储库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p><img src="/images/git-study/init.png" alt="初始化"></p><ul><li>执行完git init后本地仓库已初始化完成。ls -a可以查看到.git的隐藏文件</li></ul><h4 id="更新仓库内容"><a href="#更新仓库内容" class="headerlink" title="更新仓库内容"></a>更新仓库内容</h4><h5 id="创建文件并修改内容"><a href="#创建文件并修改内容" class="headerlink" title="创建文件并修改内容"></a>创建文件并修改内容</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 创建一个README文件</span><br><span class="line">touch READEM.md</span><br><span class="line"><span class="meta">#</span> 写入一些内容到READEM.md</span><br><span class="line">echo 'hello,world' &gt;&gt; READEM.md</span><br><span class="line"><span class="meta">#</span> 打印READEM.md文件内容</span><br><span class="line">cat READEM.md</span><br></pre></td></tr></table></figure><p><img src="/images/git-study/touch1.png" alt="创建文件"></p><h5 id="查看仓库状态"><a href="#查看仓库状态" class="headerlink" title="查看仓库状态"></a>查看仓库状态</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line"><span class="meta">#</span> 或者 git status -s</span><br></pre></td></tr></table></figure><p><img src="/images/git-study/status.png" alt="查看仓库状态"></p><h5 id="将变更的文件纳入版本管理"><a href="#将变更的文件纳入版本管理" class="headerlink" title="将变更的文件纳入版本管理"></a>将变更的文件纳入版本管理</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line"><span class="meta">#</span> . 是将所有的文件递归纳入版本管理，若单个添加git add READEM.md 即可</span><br></pre></td></tr></table></figure><p><img src="/images/git-study/add.png" alt="纳入版本管理"></p><h5 id="将纳入版本管理的文件提交到本地仓库"><a href="#将纳入版本管理的文件提交到本地仓库" class="headerlink" title="将纳入版本管理的文件提交到本地仓库"></a>将纳入版本管理的文件提交到本地仓库</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m 'first commit'</span><br></pre></td></tr></table></figure><p><img src="/images/git-study/commit.png" alt="提交"></p><h5 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git log  # 命令是查看全部提交日志  </span><br><span class="line">git log -2  # 查看最近2次的提交日志  </span><br><span class="line">git log -p  # 查看历史纪录以来哪几行被修改  </span><br><span class="line">git log --stat --summary # 查看每个版本变动的档案和行数</span><br></pre></td></tr></table></figure><p><img src="/images/git-study/log.png" alt="查看日志"></p><blockquote><p>日志的样式略微难看，这里给大家推荐一个配置</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 给git log起一个别名：git lg</span><br><span class="line">git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(red)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 更改之后</span><br><span class="line">git lg  # 命令是查看全部提交日志  </span><br><span class="line">....</span><br></pre></td></tr></table></figure><p><img src="/images/git-study/lg.png" alt="查看日志"></p><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><h5 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch dev1</span><br></pre></td></tr></table></figure><blockquote><p>Git创建分支时，它只是创建一个带有该分支名称的指针，该指针指向已创建分支的commit</p></blockquote><h5 id="切换到dev1分支进行开发"><a href="#切换到dev1分支进行开发" class="headerlink" title="切换到dev1分支进行开发"></a>切换到dev1分支进行开发</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev1</span><br></pre></td></tr></table></figure><p><img src="/images/git-study/branch.png" alt="创建分支和切换到dev1分支"></p><blockquote><p>接下来的所有操作都在dev1分支上，我们仍然来更新仓库的文件内容</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">touch dev1.txt</span><br><span class="line">echo 'this is text file' &gt;&gt; dev1.txt</span><br><span class="line"><span class="meta">#</span> 查看状态</span><br><span class="line">git status -s</span><br><span class="line"><span class="meta">#</span> 纳入版本控制</span><br><span class="line">git add .</span><br><span class="line"><span class="meta">#</span> 提交</span><br><span class="line">git commit -m 'create a dev1 text file'</span><br><span class="line"><span class="meta">#</span> 查看日志</span><br><span class="line">git lg</span><br></pre></td></tr></table></figure><p><img src="/images/git-study/dev1.png" alt="进行开发"></p><h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><blockquote><p>假设，这条分支的任务已完成，我们切换到主线master上去</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><blockquote><p>此时，我们再查看日志，并没有刚刚提交的’create a dev1 text file’。原因是：之前所有的操作都在dev1分支上执行，现在切回到master分支自然没有刚刚的日志记录。在实际项目开发中写了不就没有意义了吗？<strong> 所有我们要将dev1分支与master合并！</strong></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev1</span><br></pre></td></tr></table></figure><p><img src="/images/git-study/merge1.png" alt="合并分支"></p><h5 id="合并问题"><a href="#合并问题" class="headerlink" title="合并问题"></a>合并问题</h5><blockquote><p>合并之后再次查看日志，你会发现并没有存在dev1分支的存在，与我们相像的并不一致，这是为何？<br>原因：这是因为Git使用快进模式(fast-forward)合并了分支。这里需要注意git给我们打印的输出信息,如上图所示：master和dev1是共同的祖先！<br><strong> 在我们合并分支时，不推荐使用fast-forward模式！可以通过–no-ff(无快进模式)命令来处理</strong></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 新建分支dev2重复dev1的操作，再次合并</span><br><span class="line">git merge --no-ff dev2</span><br></pre></td></tr></table></figure><p><img src="/images/git-study/merge2.png" alt="合并分支"><br><img src="/images/git-study/merge3.png" alt="合并分支"></p><blockquote><p>通过这种方式来合并分支，可以完美的显示分支的生命迹象！</p></blockquote><h5 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h5><blockquote><p>假设分支合并完成，此分支已没有作用，我们应该移除此分支，以后可再次创建命名为dev1分支</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev1</span><br></pre></td></tr></table></figure><h4 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h4><blockquote><p>下面模拟一下合并冲突问题！</p></blockquote><ul><li>在master分支上更新仓库并提交<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> master分支更新仓库并提交</span><br><span class="line">echo 'this is a test log' &gt;&gt; README.md</span><br><span class="line">git status -s</span><br><span class="line">git add .</span><br><span class="line">git commit -m 'readme file change content'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> master分支更新仓库并提交</span><br><span class="line">echo 'this is two' &gt;&gt; README.md</span><br><span class="line">git status -s</span><br><span class="line">git add .</span><br><span class="line">git commit -m 'readme file change content two'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 切换到dev2分支，更新仓库并提交</span><br><span class="line">git checkout dev2</span><br><span class="line">echo 'this is dev2 change' &gt;&gt; README.md</span><br><span class="line">git status -s</span><br><span class="line">git add .</span><br><span class="line">git commit -m 'readme file change content dev2 change'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 再次切换到master分支，更新仓库并提交</span><br><span class="line">git checkout master</span><br><span class="line">echo 'this is three' &gt;&gt; README.md</span><br><span class="line">git status -s</span><br><span class="line">git add .</span><br><span class="line">git commit -m 'readme file change content three'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 做完上述工作，接下来合并</span><br></pre></td></tr></table></figure></li></ul><h5 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev2</span><br></pre></td></tr></table></figure><p><img src="/images/git-study/merge4.png" alt="合并分支"></p><blockquote><p>很显然，合并失败！此时，两个分支的版本存在冲突，Git已经不知道怎么做了。<strong> 在master更新仓库并提交之后版本已经改变，master已不是上次上传的版本，而dev2分支还是从上一次合并的HEAD开始；所以这时是无法合并的。而Git所做的事情是：指出存在这些内容不兼容的部分。</strong></p></blockquote><ul><li>接着，我们看一下仓库状态：git status</li></ul><p><img src="/images/git-study/status2.png" alt="状态"></p><ul><li><p>进入README文件(vi README.md)查看更新的内容，会发现多出了&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD、========、&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;dev2，这里有两个部分：</p><ul><li>第一部分：在&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD和=======之间，是master分支更新的内容；</li><li>第二部分：在=======和&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev2之间，是dev2分支更新的内容；<br><img src="/images/git-study/readme.png" alt="readme文件"></li></ul></li><li><p><strong>解决办法</strong></p><ul><li>使用HEAD-master版本</li><li>使用dev2版本</li><li>两个版本的组合</li></ul></li></ul><ol><li>使用HEAD-master版本<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 将master分支提交的信息保留，去掉dev2分支的内容，并且去掉&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD、========、&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;dev2</span><br><span class="line"><span class="meta">#</span> 保存如下：</span><br><span class="line">this is a test log</span><br><span class="line">this is two</span><br><span class="line">this is three</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> esc退出编辑模式，快捷键shift + :  再输入wq，回车即可，保存并退出</span><br><span class="line"><span class="meta">#</span> 查看状态</span><br><span class="line">git status -s</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><strong> 在一开始合并时，查看仓库状态README文件还是Unmerge 状态，在git status -s下是红色的：UU README.md；而现在是AA README.md </strong><br><img src="/images/git-study/status4.png" alt="readme文件"></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m 'save HEAD version, remove dev2 version'</span><br><span class="line"><span class="meta">#</span> 这里虽然使用了HEAD版本，但是保存了dev2分支的生命迹象</span><br><span class="line"><span class="meta">#</span> 合并完成，删除dev2分支</span><br><span class="line">git branch -d dev2</span><br></pre></td></tr></table></figure><ol start="2"><li><p>使用dev2版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 与第一种解决办法同理</span><br></pre></td></tr></table></figure></li><li><p>两个版本的组合</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 两个版本组合就是两者都保留，所以只需要去掉&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD、========、&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;dev2即可</span><br><span class="line"><span class="meta">#</span> esc退出编辑模式，快捷键shift + :  再输入wq，回车即可，保存并退出</span><br><span class="line">git add .</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>版本合并完之后如下：</p></blockquote><p><img src="/images/git-study/merge6.png" alt="readme文件"></p><h4 id="版本回退-删除"><a href="#版本回退-删除" class="headerlink" title="版本回退(删除)"></a>版本回退(删除)</h4><ul><li>命令<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;版本号&gt;  # 回退到对应的版本号，这里的版本号就是日志前面的7个字符</span><br><span class="line">git reset --hard -HEAD^   # 删除最后一次提交的版本，也就是回退到最后倒数第二次版本</span><br><span class="line">git reset --hard -HEAD~   # 删除最后一次提交的版本，也就是回退到最后倒数第二次版本</span><br><span class="line">git reset --hard -HEAD^^  # 删除最后两次次提交的版本，也就是回退到最后倒数第三次版本</span><br><span class="line">.... 其他的依次类推</span><br></pre></td></tr></table></figure></li></ul><h4 id="clone命令"><a href="#clone命令" class="headerlink" title="clone命令"></a>clone命令</h4><blockquote><p>在码云或者Github上要克隆别人的代码，需要用到clone命令</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;仓库地址:url/ssh&gt;  # 如下图所示</span><br></pre></td></tr></table></figure><p><img src="/images/git-study/gitee.png" alt="readme文件"></p>]]></content>
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Git </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>个人博客搭建详细解读</title>
      <link href="/2018/08/04/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E8%A7%A3%E8%AF%BB/"/>
      <url>/2018/08/04/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E8%A7%A3%E8%AF%BB/</url>
      <content type="html"><![CDATA[<hr><a id="more"></a><blockquote><p>前言</p></blockquote><pre><code>本篇介绍在Mac系统下基于Hexo搭建属于自己的博客！</code></pre><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><blockquote><p>个人觉得Mac的终端命令行工具非常好用，这里我们需要使用终端安装Homebrew、Nodejs</p></blockquote><ul><li><p>安装Homebrew: <a href="https://brew.sh/index_zh-cn" target="_blank" rel="noopener">https://brew.sh/index_zh-cn</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span><br></pre></td></tr></table></figure></li><li><p>通过brew安装Nodejs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>因为hexo是基于Nodejs所以我们需要安装nodejs</p></blockquote><ul><li>Mac终端自带Git命令，所以无需安装，如没有：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure></li></ul><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><blockquote><p>已经做完准备工作，接下来使用npm安装hexo（nodejs中自带npm）</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 若上述出现错误使用：</span><br><span class="line">sudo npm install -g hexo</span><br></pre></td></tr></table></figure><h3 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 创建一个文件夹</span><br><span class="line">mkdir blog</span><br><span class="line"><span class="meta">#</span> 打开创建的文件夹</span><br><span class="line">cd blog/</span><br><span class="line"><span class="meta">#</span> 以上两步可简写为：mkdir blog &amp; cd blog</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 初始化博客</span><br><span class="line">hexo init</span><br><span class="line"><span class="meta">#</span> 安装依赖包</span><br><span class="line">npm install</span><br><span class="line"><span class="meta">#</span> 等待下载完，上述完成博客已初步完成</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 生成静态html文件,可简写为：hexo g</span><br><span class="line">hexo generate</span><br><span class="line"><span class="meta">#</span> 启动服务,可简写为：hexo s</span><br><span class="line">hexo serve</span><br></pre></td></tr></table></figure><ul><li>执行命令之后如下即可通过：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 访问<br><img src="/images/blog/hexo_s.png" alt="启动服务"></li></ul><h3 id="撰写博客"><a href="#撰写博客" class="headerlink" title="撰写博客"></a>撰写博客</h3><ul><li><p>新建一篇博客（文章）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new "我的第一篇博客^_^"</span><br></pre></td></tr></table></figure></li><li><p>目录结构如下<br><img src="/images/blog/page.png" alt="启动服务"></p></li><li>选中刚刚所建的文件，编辑内容，页面使用的MarkDown语法，撰写一篇漂亮的文章先看看Mark语法</li><li>推荐MarkDown语法学习的博客：<a href="https://segmentfault.com/markdown" target="_blank" rel="noopener">https://segmentfault.com/markdown</a></li></ul><blockquote><p>上述步骤完成之后，在重新生成启动服务器</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 这里新增一个命令:清除缓存，这个命令可以将public文件夹移除</span><br><span class="line">hexo clean</span><br><span class="line"><span class="meta">#</span> 生成静态html文件，而这个命令是重新生成一个public文件夹，所有的资源文件都在该文件夹下</span><br><span class="line">hexo generate</span><br><span class="line"><span class="meta">#</span> 启动服务</span><br><span class="line">hexo serve</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>代理模式-ProxyPattern</title>
      <link href="/2018/08/01/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-ProxyPattern/"/>
      <url>/2018/08/01/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-ProxyPattern/</url>
      <content type="html"><![CDATA[<hr><a id="more"></a><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><h4 id="代理模式与装饰者模式"><a href="#代理模式与装饰者模式" class="headerlink" title="代理模式与装饰者模式:"></a>代理模式与装饰者模式:</h4><ul><li>相同点:<ol><li>前提条件：装饰者(代理者)与被装饰者(委托者)要继承相同的父类或实现相同的接口。</li><li>都可以增强某个类的方法，对程序进行扩展。</li></ol></li><li>不同点:<ol><li>代理者是为某个对象添加一个代理，以控制对这个对象的访问。而装饰者增强某个类的方法。</li><li>代理可以在调用核心方法之前做前置处理，在调用核心方法之后做后置处理。</li></ol></li></ul><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><ul><li>定义：<ol><li>为对象提供一种代理，加以控制对象的访问。</li><li>在某些特定的情况下一个对象不适合或者不能直接引用另一个对象,而代理对象可以在目标对象与客户直接起到中介作用。</li></ol></li></ul><h4 id="代理模式的组成部分"><a href="#代理模式的组成部分" class="headerlink" title="代理模式的组成部分"></a>代理模式的组成部分</h4><ul><li><strong>代理接口</strong>：代理类和委托类实现的接口</li><li><strong>代理类</strong><ul><li>负责对请求的预处理、过滤，将请求分派给委托类处理以及委托了执行完后的后续处理</li></ul></li><li><strong>委托类</strong>：真正处理核心逻辑的类</li></ul><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><ul><li><strong>定义</strong>：由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了</li></ul><blockquote><ul><li><strong>静态代理的缺点</strong></li></ul></blockquote><ul><li>代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了。</li><li>如果接口增加一个方法，除了所有委托类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。</li></ul><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><blockquote><p><strong>定义</strong></p></blockquote><ul><li>动态代理它可以直接给某一个目标对象(委托对象)生成一个代理对象，而不需要代理类存在</li><li>动态代理与静态代理模式原理是一样的，只是<strong>动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成</strong>，所以不存在代理类的字节码文件。代理者和委托者的关系是在程序运行时确定。</li></ul><h4 id="动态代理常用类详解"><a href="#动态代理常用类详解" class="headerlink" title="动态代理常用类详解"></a>动态代理常用类详解</h4><blockquote><p><strong>java.lang.reflect.Proxy</strong><br>这是 Java 动态代理机制生成的所有动态代理类的父类，它提供了一组静态方法来为一组接口动态地生成代理对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, </span></span></span><br><span class="line"><span class="function"><span class="params">                               Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span></span><br><span class="line"><span class="function">loader:指定类的装载器</span></span><br><span class="line"><span class="function">Interfaces:一组接口,委托类实现的所有接口</span></span><br><span class="line"><span class="function">H:处理器生成代理类实例</span></span><br><span class="line"><span class="function">@return:返回一个代理对象</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>java.lang.reflect.InvocationHandler</strong><br>这是调用处理器接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。每次生成动态代理类对象时都要指定一个对应的调用处理器对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">proxy:动态创建的代理者实例, 一般不要调用, 会发生递归</span></span><br><span class="line"><span class="function">method:代理对象当前所调用的方法, 只要代理调用任何方法都会走到invoke方法</span></span><br><span class="line"><span class="function">args:参数列表</span></span><br><span class="line"><span class="function">@return:返回当前被调用方法的返回值</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p><strong>java.lang.ClassLoader</strong></p></blockquote><ul><li>这是类装载器类负责将类的字节码装载到Java虚拟机（JVM）中并为其定义类对象，然后该类才能被使用。</li><li>Proxy 静态方法生成动态代理类同样需要通过类装载器来进行装载才能使用，它与普通类的唯一区别就是其字节码是由 JVM在运行时动态生成的而非预存在于任何一个 .class 文件中。 </li><li>每次生成动态代理类对象时都需要指定一个类装载器对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader loader = jay.getClass().getClassLoader();</span><br></pre></td></tr></table></figure><h4 id="Dynamic-Proxy-Example"><a href="#Dynamic-Proxy-Example" class="headerlink" title="Dynamic Proxy Example"></a>Dynamic Proxy Example</h4><ul><li><p><strong>明星接口- 代理类和委托类实现的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Star</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 发布会</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conference</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 代言广告</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endorsementAD</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>明星类 - 委托者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JayStar</span> <span class="keyword">implements</span> <span class="title">Star</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"周杰棍正在开发布会....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endorsementAD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"周杰棍正在帮百雀羚打广告....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>客户与动态代理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化一个JayStar对象</span></span><br><span class="line">        JayStar jay = <span class="keyword">new</span> JayStar();</span><br><span class="line">        <span class="comment">// 获取字节码文件对象</span></span><br><span class="line">        Class&lt;? extends JayStar&gt; clazz = jay.getClass();</span><br><span class="line">        <span class="comment">// 获取当前类的类加载器</span></span><br><span class="line">        ClassLoader loader = Client.class.getClassLoader();</span><br><span class="line">        <span class="comment">// 委托者所实现的所有接口</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span><br><span class="line"><span class="comment">         * loader:指定的类加载器</span></span><br><span class="line"><span class="comment">         * interfaces:委托者所实现的所有接口</span></span><br><span class="line"><span class="comment">         * h:处理器回调，动态设置代理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Star star = (Star) Proxy.newProxyInstance(loader, interfaces, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="comment">// 动态代理的前置处理</span></span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">will</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"发布会开始了。。。。"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 动态代理的后置处理</span></span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"发布会结束了。。。。"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Object invoke(Object proxy, Method method, Object[] args)</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@see</span> java.lang.reflect.InvocationHandler#invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])</span></span><br><span class="line"><span class="comment">             * proxy:第一个proxy指的是生成的动态代理对象</span></span><br><span class="line"><span class="comment">             * method:被调用的方法</span></span><br><span class="line"><span class="comment">             * args:调用该方法传入的参数</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                String name = method.getName();</span><br><span class="line">                <span class="keyword">if</span> (name.equals(<span class="string">"fbh"</span>)) &#123;</span><br><span class="line">                    will();</span><br><span class="line">                    jay.conference();</span><br><span class="line">                    end();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (name.equals(<span class="string">"ad"</span>)) &#123;</span><br><span class="line">                    jay.endorsementAD();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        star.conference();</span><br><span class="line">        star.endorsementAD();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>个人感想</title>
      <link href="/2018/07/22/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3/"/>
      <url>/2018/07/22/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3/</url>
      <content type="html"><![CDATA[<hr><a id="more"></a><h4 id="写博客的目的"><a href="#写博客的目的" class="headerlink" title="写博客的目的"></a>写博客的目的</h4><blockquote><p>搭建博客我的最真实的想法是：记录在编程的道路上所学的知识，所遇的BUG和所得的经验。我的初衷是希望两天能总结一篇博客，不论是技术还是心得，正所谓水滴石穿，非一日之功。人生，最难得的就是坚持！在精神上对自己激励，在心理上加一个定时任务，从而提高自己的学习效率与不断学习的习惯。<br>写博客并非是为了装x、写一篇博客也并非是Ctrl + C || Ctrl + V。技术都是开源的，能把所看所听的技术学而所用，对工作有所帮助，记录下来再写成一篇博客，这就是经验，也是对工作的总结！我个人认为定时写博客是有利无弊，进步就是不断的学习。<br>坚持学习！加油！</p></blockquote>]]></content>
      
      <categories>
          
          <category> 感言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 感言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>注解</title>
      <link href="/2018/07/21/%E6%B3%A8%E8%A7%A3/"/>
      <url>/2018/07/21/%E6%B3%A8%E8%A7%A3/</url>
      <content type="html"><![CDATA[<hr><a id="more"></a><blockquote><p>此篇是从简书移至本博客, 简书地址：<a href="https://www.jianshu.com/u/e79d7856d1ff" target="_blank" rel="noopener">https://www.jianshu.com/u/e79d7856d1ff</a></p></blockquote><h4 id="jdk中三种常见的注解-注解与类、接口平级存在"><a href="#jdk中三种常见的注解-注解与类、接口平级存在" class="headerlink" title="jdk中三种常见的注解:(注解与类、接口平级存在)"></a>jdk中三种常见的注解:(注解与类、接口平级存在)</h4><ol><li>Override:用于描述方法重写，描述该方法是从父类继承的</li><li>SuppressWarnings:压制警告的意思</li><li>Deprecated:用于描述方法过期了</li></ol><h4 id="注解属性的类型可以是哪些"><a href="#注解属性的类型可以是哪些" class="headerlink" title="注解属性的类型可以是哪些?"></a>注解属性的类型可以是哪些?</h4><ol><li>基本数据类型都可以:byte、short、int、long、float、double、char、boolean</li><li>String</li><li>注解类型</li><li>Class类型</li><li>枚举类型</li><li>以上类型的一维数组</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(value = RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation02 &#123;</span><br><span class="line">    <span class="function">String <span class="title">str</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">num</span><span class="params">()</span> <span class="keyword">default</span> 10</span>;</span><br><span class="line">    <span class="function">MyAnnotation01 <span class="title">anno</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Class <span class="title">clazz</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Color <span class="title">color</span><span class="params">()</span></span>;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h4><p>如果使用的那个注解有注解属性，那么使用的时候就要为这些注解属性赋值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation</span>02(anno = <span class="meta">@MyAnnotation</span>01, clazz = TestAnno03.class, color = Color.GREEN, str = <span class="string">"qwe"</span>, value = &#123; <span class="string">"asd"</span> &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnno03</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MyAnnotation</span>03(value = <span class="string">"qwe"</span>)</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">"张三"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@MyAnnotation</span>03(value = <span class="string">"qwe"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestAnno03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@MyAnnotation</span>03(value = <span class="string">"qwe"</span>)</span><br><span class="line">    <span class="meta">@MyAnnotation</span>01</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">@MyAnnotation</span>03(value = <span class="string">"qwe"</span>)</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="元注解就是定义在注解上的注解"><a href="#元注解就是定义在注解上的注解" class="headerlink" title="元注解就是定义在注解上的注解"></a>元注解就是定义在注解上的注解</h4><ul><li><p><strong>@ Target:表示该注解能使用在什么东西上面</strong></p><ul><li>如果取值为：METHOD表示可以用在方法上,TYPE表示可以用在类、接口、注解、枚举上</li><li>LOCAL_VARIABLE表示可以用在局部变量上，</li><li>FIELD表示可以用在成员变量上</li><li>CONSTRUCTOR表示能够用在构造函数上</li></ul></li><li><p><strong>@ Retention:表示该注解保留到什么阶段</strong></p><ul><li>SOURCE:源码阶段</li><li>CLASS:编译阶段</li><li>RUNTIME:运行阶段<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(value = RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(value = &#123; ElementType.METHOD,ElementType.TYPE,ElementType.LOCAL_VARIABLE,ElementType.FIELD,ElementType.CONSTRUCTOR &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation03 &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="解析注解"><a href="#解析注解" class="headerlink" title="解析注解"></a>解析注解</h4><ul><li><p><strong>获取TestAnno03类上的所有注解 -&gt; Annotation[]</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取该类字节码文件对象,Class类实现了AnnotatedElement接口，所以就有该接口的的那四个方法</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.itheima.annotation.meta.TestAnno03"</span>);</span><br><span class="line">Annotation[] annotations = clazz.getAnnotations();</span><br></pre></td></tr></table></figure></li><li><p><strong>判断name成员变量上有没有@MyAnnotation03注解 -&gt; boolean</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取字节码文件对象</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.itheima.annotation.meta.TestAnno03"</span>);</span><br><span class="line"><span class="comment">// 获取所有的字段</span></span><br><span class="line">Field field = clazz.getField(<span class="string">"name"</span>);</span><br><span class="line"><span class="keyword">boolean</span> flag = field.isAnnotationPresent(MyAnnotation03.class);</span><br><span class="line">System.out.println(flag);</span><br></pre></td></tr></table></figure></li><li><p><strong>获取fn1方法上的MyAnnotation01注解的对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.itheima.annotation.meta.TestAnno03"</span>);</span><br><span class="line"><span class="comment">//获取fn1方法</span></span><br><span class="line">Method method = clazz.getMethod(<span class="string">"fn1"</span>);</span><br><span class="line">        </span><br><span class="line">MyAnnotation01 annotation = method.getAnnotation(MyAnnotation01.class);</span><br><span class="line">System.out.println(annotation);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lambda简介</title>
      <link href="/2018/07/21/Lambda%E7%AE%80%E4%BB%8B/"/>
      <url>/2018/07/21/Lambda%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<hr><a id="more"></a><blockquote><p>此篇是从简书移至本博客, 简书地址：<a href="https://www.jianshu.com/u/e79d7856d1ff" target="_blank" rel="noopener">https://www.jianshu.com/u/e79d7856d1ff</a></p></blockquote><h3 id="一、引入lambda"><a href="#一、引入lambda" class="headerlink" title="一、引入lambda"></a>一、引入lambda</h3><blockquote><p>定义：lambda就是简化了匿名内部类</p></blockquote><p>使用前提：安装JDK 8</p><p>通过一个Example一步一步来达到lambda表达式的相关 : </p><h4 id="筛选出集合内大于50的数"><a href="#筛选出集合内大于50的数" class="headerlink" title="筛选出集合内大于50的数"></a>筛选出集合内大于50的数</h4><ul><li><p>普通Java代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">          Random random = <span class="keyword">new</span> Random();</span><br><span class="line">          <span class="keyword">int</span> nextInt = random.nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line">          list.add(nextInt);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"原:"</span> + list);</span><br><span class="line">      System.out.println(<span class="string">"筛选出大于50的数"</span>);</span><br><span class="line">      filter(list);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">          <span class="keyword">if</span> (integer &gt; <span class="number">50</span>) &#123;</span><br><span class="line">              System.out.println(integer);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>匿名类部类实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">          Random random = <span class="keyword">new</span> Random();</span><br><span class="line">          <span class="keyword">int</span> nextInt = random.nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line">          list.add(nextInt);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"原:"</span> + list);</span><br><span class="line">      </span><br><span class="line">      Checker checker = <span class="keyword">new</span> Checker() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(Integer i)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> i &gt; <span class="number">50</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      filter(list, checker);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(List&lt;Integer&gt; list, Checker checker)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">          <span class="keyword">if</span> (checker.check(integer)) &#123;</span><br><span class="line">              System.out.println(integer);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Checker接口</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Checker</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(Integer i)</span></span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>一步一步演变成lambda表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> nextInt = random.nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line">        list.add(nextInt);</span><br><span class="line">    &#125;</span><br><span class="line">    Checker c1 = <span class="keyword">new</span> Checker() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(Integer i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i &gt; <span class="number">50</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(<span class="string">"筛选出大于50的数---&gt;1"</span>);</span><br><span class="line">    filter(list, c1);</span><br><span class="line">    </span><br><span class="line">    Checker c2 = (Integer i) -&gt; &#123; <span class="keyword">return</span> i &gt; <span class="number">50</span>; &#125;;</span><br><span class="line">    System.out.println(<span class="string">"筛选出大于50的数---&gt;2"</span>);</span><br><span class="line">    filter(list, c2);</span><br><span class="line">    </span><br><span class="line">    Checker c3 = (Integer i) -&gt; i &gt; <span class="number">50</span>;</span><br><span class="line">    System.out.println(<span class="string">"筛选出大于50的数---&gt;3"</span>);</span><br><span class="line">    filter(list, c3);</span><br><span class="line">    </span><br><span class="line">    Checker c4 = i -&gt; i &gt; <span class="number">50</span>;</span><br><span class="line">    System.out.println(<span class="string">"筛选出大于50的数---&gt;4"</span>);</span><br><span class="line">    filter(list, c4);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"筛选出大于50的数---&gt;5"</span>);</span><br><span class="line">    filter(list, i -&gt; i &gt; <span class="number">50</span>);</span><br><span class="line">    </span><br><span class="line">    List&lt;Integer&gt; is = list.stream().filter(i -&gt; i &gt; <span class="number">50</span>).collect(Collectors.toList());</span><br><span class="line">    System.out.println(is);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(List&lt;Integer&gt; list, Checker checker)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (checker.check(integer)) &#123;</span><br><span class="line">            System.out.println(integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.匿名类的正常写法</span><br><span class="line">    Checker checker = <span class="keyword">new</span> Checker() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(Integer i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i &gt; <span class="number">50</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>. 把外面的壳子去掉,只保留方法参数和方法体,参数和方法体之间加上符号 -&gt;</span><br><span class="line">    Checker c2 = (Integer i) -&gt; &#123; <span class="keyword">return</span> i &gt; <span class="number">50</span>; &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>. 把<span class="keyword">return</span>和&#123;&#125;去掉</span><br><span class="line">    Checker c3 = (Integer i) -&gt; i &gt; <span class="number">50</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>. 去掉参数小括号,得到Lambda表达式</span><br><span class="line">    Checker c4 = i -&gt; i &gt; <span class="number">50</span>;</span><br></pre></td></tr></table></figure><p>####排序例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 匿名类部类</span></span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO lambda表达式</span></span><br><span class="line">Collections.sort(list, (o1, o2) -&gt; o1.compareTo(o2));</span><br></pre></td></tr></table></figure></p><h3 id="二、聚合操作"><a href="#二、聚合操作" class="headerlink" title="二、聚合操作"></a>二、聚合操作</h3><blockquote><p><strong>遍历: 传统方式与聚合操作遍历数据</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> nextInt = random.nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line">    list.add(nextInt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 传统方式for循环遍历数据</span></span><br><span class="line"><span class="keyword">for</span> (Integer itg : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (itg &gt; <span class="number">50</span>) &#123;</span><br><span class="line">        System.out.println(itg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 聚合操作遍历数据</span></span><br><span class="line">list.stream().filter(itg -&gt; itg &gt; <span class="number">50</span>).forEach(itg -&gt; System.out.println(itg));</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO lambda的方法引用(简介: 静态方法、对象方法等等的引入)</span></span><br><span class="line">list.stream().filter(itg -&gt; itg &gt; <span class="number">50</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><blockquote><p><strong>Stream和管道的概念</strong></p></blockquote><ol><li>Stream: Stream是一系列元素, 象生产线上的罐头, 一罐一罐的生产出来</li><li>管道: 是指一系列聚合操作, 分为：管道源、中间操作、结束操作。</li></ol><blockquote><p>管道源：在前面的例子里面，管道源是list集合</p></blockquote><ul><li>将Collection切换到管道源只需要调用stream()方法即可：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream();</span><br></pre></td></tr></table></figure><ul><li>数组却没有stream()方法，需要使用:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">Arrays.stream(arr).forEach(System.out::println);</span><br></pre></td></tr></table></figure><blockquote><p>中间操作：也叫‘懒’操作，并不会进行变量，每一步中间操作都会返回一个Stream对象</p></blockquote><ul><li><p>对元素进行筛选</p><ul><li>filter        匹配</li><li>distinct   去除重复(根据equals判断)</li><li>sorted         自然排序</li><li>sorted(Comparator<t>) 指定排序</t></li><li>limit 保留</li><li>skip 忽略</li></ul></li><li><p>转换为其他形式的流</p><ul><li>mapToDouble 转换为double的流</li><li>map 转换为任意类型的流</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 去重排序打印</span></span><br><span class="line">list.stream().distinct().sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//TODO 保留前三个元素并打印</span></span><br><span class="line">list.stream().limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//TODO 忽略前三个</span></span><br><span class="line">list.stream().skip(<span class="number">3</span>).forEach( System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//TODO 转换任意类型的Stream</span></span><br><span class="line">list.stream().map(itg -&gt; itg + <span class="string">"-hello"</span>).forEach( System.out::println);</span><br></pre></td></tr></table></figure><blockquote><p><strong>结束操作</strong>: 结束操作不会返回Stream，但是会返回int、float、String、 Collection或者像forEach或者什么都不返回</p></blockquote><ul><li>forEach() 遍历每个元素</li><li>toArray() 转换为数组</li><li>min(Comparator<t>) 取最小的元素</t></li><li>max(Comparator<t>) 取最大的元素</t></li><li>count() 总数</li><li>findFirst() 第一个元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历集合中的每个数据</span></span><br><span class="line">list.stream().forEach(h-&gt;System.out.print(h));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line">Object[] array= list.stream().toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回最小值</span></span><br><span class="line">Integer integer = list.stream().min((a1, a2) -&gt; a1.compareTo(a2)).get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回最大值</span></span><br><span class="line">Integer integer = list.stream().max((a1, a2) -&gt; a1.compareTo(a2)).get();  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据的总数</span></span><br><span class="line"><span class="keyword">long</span> count = list.stream().count();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个元素</span></span><br><span class="line">Integer integer = list.stream().findFirst().get();</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android SharedPreferencesUtil工具类</title>
      <link href="/2018/07/21/Android-SharedPreferencesUtil%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2018/07/21/Android-SharedPreferencesUtil%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      <content type="html"><![CDATA[<hr><a id="more"></a><blockquote><p>此篇是从简书移至本博客, 简书地址：<a href="https://www.jianshu.com/u/e79d7856d1ff" target="_blank" rel="noopener">https://www.jianshu.com/u/e79d7856d1ff</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class SharedPreferencesUtil &#123;</span><br><span class="line">    public static final String mTAG = &quot;test&quot;;</span><br><span class="line">    // 创建一个写入器</span><br><span class="line">    private static SharedPreferences mPreferences;</span><br><span class="line">    private static SharedPreferences.Editor mEditor;</span><br><span class="line">    private static SharedPreferencesUtil mSharedPreferencesUtil;</span><br><span class="line"></span><br><span class="line">    // 构造方法</span><br><span class="line">    public SharedPreferencesUtil(Context context) &#123;</span><br><span class="line">        mPreferences =   context.getSharedPreferences(mTAG,Context.MODE_PRIVATE);</span><br><span class="line">        mEditor = mPreferences.edit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 单例模式</span><br><span class="line">    public static SharedPreferencesUtil getInstance(Context context) &#123;</span><br><span class="line">        if (mSharedPreferencesUtil ==null)&#123;</span><br><span class="line">            mSharedPreferencesUtil =new SharedPreferencesUtil(context);</span><br><span class="line">        &#125;</span><br><span class="line">        return  mSharedPreferencesUtil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 存入数据</span><br><span class="line">    public void putSP(String key,String value) &#123;</span><br><span class="line">        mEditor.putString(key,value);</span><br><span class="line">        mEditor.commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取数据</span><br><span class="line">    public String getSP(String key) &#123;</span><br><span class="line">        return mSharedPreferencesUtil.getString(key,&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 移除数据</span><br><span class="line">    public void removeSP(String key) &#123;</span><br><span class="line">        mEditor.remove(key);</span><br><span class="line">        mEditor.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IOS面试问题</title>
      <link href="/2018/07/21/IOS%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
      <url>/2018/07/21/IOS%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<hr><a id="more"></a><blockquote><p>此篇是从简书移至本博客, 简书地址：<a href="https://www.jianshu.com/u/e79d7856d1ff" target="_blank" rel="noopener">https://www.jianshu.com/u/e79d7856d1ff</a></p></blockquote><h2 id="HTTP的POST和GET区别"><a href="#HTTP的POST和GET区别" class="headerlink" title="HTTP的POST和GET区别?"></a>HTTP的POST和GET区别?</h2><blockquote><p>http:Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。</p></blockquote><ol><li>根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。</li><li>根据HTTP规范，POST表示可能修改变服务器上的资源的请求。<blockquote><p>总结：GET是向服务器发索取数据的一种请求，而POST是向服务器提交数据的一种请求</p></blockquote></li></ol><h2 id="使用atomic一定是线程安全的吗"><a href="#使用atomic一定是线程安全的吗" class="headerlink" title="使用atomic一定是线程安全的吗?"></a>使用atomic一定是线程安全的吗?</h2><ol><li>这个问题很少遇到，但是答案当然不是</li><li>atomic在set方法里加了锁，防止了多线程一直去写这个property，造成难以预计的数值<blockquote><p>总结：atomic有个很大的问题是很慢，要比nonatomic慢20倍。当然最后建议这种数值数值变化可以让服务器来做</p></blockquote></li></ol><h2 id="数据库建表的时候索引有什么用"><a href="#数据库建表的时候索引有什么用" class="headerlink" title="数据库建表的时候索引有什么用?"></a>数据库建表的时候索引有什么用?</h2><blockquote><p>有什么用 ：数据库中的索引使您可以快速找到表或索引视图中的特定信息。索引包含从表或视图中一个或多个列生成的键，以及映射到指定数据的存储位置的指针。通过创建设计良好的索引以支持查询，可以显著提高数据库查询和应用程序的性能。索引可以减少为返回查询结果集而必须读取的数据量。索引还可以强制表中的行具有唯一性，从而确保表数据的数据完整性</p></blockquote><h2 id="冒泡算法思想"><a href="#冒泡算法思想" class="headerlink" title="冒泡算法思想"></a>冒泡算法思想</h2><blockquote><p>含有n个元素数组原则上要进行n次排序，从第一个数开始，依次比较前一个数与后一个数的大小。如果前一个数比后一个数大，则进行交换。一轮过后，最大的数将会出现称为最末位的数组元素。第二轮则去掉最后一个数，对前n-1个数在按照以上步骤找出最大数，该数将成为倒数第二的数组元素<br>具体代码如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *number = [NSMutableArray arrayWithObjects:@&quot;53&quot;,@&quot;47&quot;,@&quot;34&quot;,@&quot;98&quot;,@&quot;23&quot;, nil];</span><br><span class="line">        NSLog(@&quot;排序前：%@&quot;,number);</span><br><span class="line">        //比较的趟数</span><br><span class="line">        for (int i = 0; i &lt; 5-1; i++) &#123;</span><br><span class="line">            NSLog(@&quot;\n第%d次:%@&quot;,i+1,number);</span><br><span class="line">            //比较的次数</span><br><span class="line">            for (int j = 0; j &lt; 5-1-i; j++) &#123;</span><br><span class="line">                if ([number[j] integerValue] &gt; [number[j+1] integerValue]) &#123;</span><br><span class="line">                    //根据比升序排序</span><br><span class="line">                    NSInteger temp = [number[j] integerValue];</span><br><span class="line">                    number[j] = number[j+1];</span><br><span class="line">                    //将string转化成对象</span><br><span class="line">                    number[j+1] = [NSString stringWithFormat:@&quot;%ld&quot;,temp];</span><br><span class="line">                &#125;</span><br><span class="line">                NSLog(@&quot;\n第%d次%d趟:%@&quot;,i+1,j+1,number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;排序后：%@&quot;,number);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="iOS里如何做数据持久化"><a href="#iOS里如何做数据持久化" class="headerlink" title="iOS里如何做数据持久化?"></a>iOS里如何做数据持久化?</h2><blockquote><p>所谓数据持久化，就是将数据保存在硬盘当中，使得数据可以在应用程序启动后继续访问之前保存的数据。又以下几种方式：</p></blockquote><ol><li>plist文件（例：天气城市列表）</li><li>sqlite 数据库</li><li>coredata 苹果自带数据库 (封装了sqlite数据库，使用对象对sqlite进行操作)</li><li>NSUserDefaults（preference 偏好设置）轻量保存数据</li><li>NSKeyeArchiver（归档）</li></ol><h2 id="Objective-C的类可以多重继承吗-可以实现多个接口吗？category是什么"><a href="#Objective-C的类可以多重继承吗-可以实现多个接口吗？category是什么" class="headerlink" title="Objective-C的类可以多重继承吗? 可以实现多个接口吗？category是什么?"></a>Objective-C的类可以多重继承吗? 可以实现多个接口吗？category是什么?</h2><blockquote><p>Objective-C不能多重继承；可以实现多个接口，通过多个接口可以实现多重继承；category是类别，一般情况用分类好，用category仅对本类有效。</p></blockquote><h2 id="import-跟-include的区别？-class呢？-import”-“-跟-import-lt-gt-有什么区别？"><a href="#import-跟-include的区别？-class呢？-import”-“-跟-import-lt-gt-有什么区别？" class="headerlink" title="#import 跟 #include的区别？@class呢？#import” “ 跟 #import&lt; &gt;有什么区别？"></a>#import 跟 #include的区别？@class呢？#import” “ 跟 #import&lt; &gt;有什么区别？</h2><ol><li>import是oc导入头文件的关键字</li><li>include是c/c++导入头文件的关键字</li><li>@class是告诉编译器某个类的申明，当执行时才去查看类的实现文件，可以解决头文件的相互包含</li><li>import&lt; &gt;是用来包含系统文件头文件</li><li>import” “是用来包含用户头文件</li></ol><h2 id="什么情况下使用weak和assign，有何不同"><a href="#什么情况下使用weak和assign，有何不同" class="headerlink" title="什么情况下使用weak和assign，有何不同"></a>什么情况下使用weak和assign，有何不同</h2><ol><li>assign是指针赋值，不对引用计数操作，使用之后如果没有设置nil，可能就会产生（野）指针</li><li>weak一旦不进行，则不会再使用，就不会产生野指针</li></ol><h2 id="项目里什么时候选择GCD，什么时候选择NSOperation项目中使用"><a href="#项目里什么时候选择GCD，什么时候选择NSOperation项目中使用" class="headerlink" title="项目里什么时候选择GCD，什么时候选择NSOperation项目中使用"></a>项目里什么时候选择GCD，什么时候选择NSOperation项目中使用</h2><ol><li>NSOperation的优点是对线程的高度抽象，在项目中使用它，使项目结构更好，子类化NSOperation的设计思路，使具有面向对象的优点（复用，封装），使得线程在项目中使用简单，简易在复杂项目中使用</li><li>GCD的优点是使用起来非常简单、易用对于不复杂的多线程操作，会节省代码量，而block参数使用，使代码更易读</li></ol><h2 id="UIView和CALayer的关系"><a href="#UIView和CALayer的关系" class="headerlink" title="UIView和CALayer的关系"></a>UIView和CALayer的关系</h2><blockquote><p>UIView是依赖于CALayer提供的内容，CALayer依赖于UIView提供的界面绘制内容。CALayer是这一切的基础，如果没有CALayer，UIView也不会存在；UIView是一个特殊的CALayer实现，添加了响应事件能力</p><p>结论：UIView来自CALayer，高于CALayer，UIView所有特性来源于CALayer的支持</p></blockquote><h2 id="沙盒"><a href="#沙盒" class="headerlink" title="沙盒"></a>沙盒</h2><ol><li>应用程序可以在自己的沙盒里面运作，但是不能访问其他的应用程序沙盒</li><li>应用程序之间不能共享数据，沙盒里面文件不能被复制到其他文件中</li><li>沙盒有三个目录文件夹<ul><li>Documents：一般应该把应用程序的数据写到这里，用于存储应用程序数据</li><li>Library：下有两个文件夹:<ul><li>Caches存储应用程序再次启动所需的信息</li><li>Preferences包含应用程序偏好设置文件</li></ul></li><li>Temp：存放临时文件，即应用程序再次启动不需要的文件</li></ul></li></ol><h2 id="连接静态库"><a href="#连接静态库" class="headerlink" title="连接静态库"></a>连接静态库</h2><blockquote><p>静态库是程序代码的集合，共享代码的一种方式，静态库是闭源形式的存在的.a和.framework连接时，静态库文件会被复制到可执行文件中，被多次使用就会有冗余拷贝，相当于java中的jar包，把一类编译到一个包中</p></blockquote><h2 id="打包程序"><a href="#打包程序" class="headerlink" title="打包程序"></a>打包程序</h2><blockquote><p>在开始将程序提交到App Store之前，需要一个App Store账号，一个有效的发布证书，以及app描述文件</p><p>在itcunesconnect网站上，创建app应用，设置对应信息，上传app打包文件提交等待审核</p></blockquote><h2 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h2><blockquote><p>顾名思义：Model、View、Controller</p></blockquote><blockquote><p>优点:</p></blockquote><ol><li>开发人员只用关注整层结构中某一层</li><li>降低层与层之间的依赖</li><li>降低层与层之间的依赖</li><li>利于各层逻辑的复用</li></ol><blockquote><p>缺点:降低了系统性能，如不采用分层式结构，很多业务可以直接访问数据库获取数据，现在必须通过中间层来完成</p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> iOS </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS原生搭建一个App骨架</title>
      <link href="/2018/07/21/iOS%E5%8E%9F%E7%94%9F%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAApp%E9%AA%A8%E6%9E%B6/"/>
      <url>/2018/07/21/iOS%E5%8E%9F%E7%94%9F%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAApp%E9%AA%A8%E6%9E%B6/</url>
      <content type="html"><![CDATA[<hr><a id="more"></a><blockquote><p>此篇是从简书移至本博客, 简书地址：<a href="https://www.jianshu.com/u/e79d7856d1ff" target="_blank" rel="noopener">https://www.jianshu.com/u/e79d7856d1ff</a></p></blockquote><h2 id="主流的方式搭建一个App骨架"><a href="#主流的方式搭建一个App骨架" class="headerlink" title="主流的方式搭建一个App骨架"></a>主流的方式搭建一个App骨架</h2><blockquote><p>先看效果图</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/2007033-09202ebf2bf397c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="底部按钮"></p><blockquote><p>UITabBarController实现底部按钮<br>本文章的内容为：学会搭建类似于QQ界面框架</p></blockquote><blockquote><p>第一步：设置窗口的主视图，在AppDelegate.m中didFinishLaunchingWithOptions:方法中将TabBarViewController的对象作为窗口主视图。(TabBarViewController是自己创建的一个类，同时继承UITabBarController) </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    //创建窗口，并初始化</span><br><span class="line">    _window = [[UIWindow alloc]initWithFrame:[UIScreen mainScreen].bounds];</span><br><span class="line">    //创建一个TabBarViewController对象</span><br><span class="line">    TabBarViewController * tabBar = [[TabBarViewController alloc]init];</span><br><span class="line">    //将TabBarViewController对象作为窗口的根控制器</span><br><span class="line">    _window.rootViewController = tabBar;</span><br><span class="line">    //显示窗口</span><br><span class="line">    [_window makeKeyAndVisible];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第二步：创建对应的控制器（UIViewController）<br>下图是我的文件结构目录<br>动态、联系人、消息文件就是对应的ViewController</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/2007033-6f0161f33b81d53b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这是我的文件结构"></p><blockquote><p>✨✨核心部分✨✨<br>当前搭建底部导航栏的主流方式<br>在TabBarViewController.m中</p></blockquote><blockquote><p>1.先导入头文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;TabBarViewController.h&quot;</span><br><span class="line">#import &quot;MessageViewController.h&quot;</span><br><span class="line">#import &quot;ContactViewController.h&quot;</span><br><span class="line">#import &quot;DynamicViewController.h&quot;</span><br></pre></td></tr></table></figure><blockquote><p>2.以下是对应代码以及参数的释义</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//创建一个视图对象</span><br><span class="line">MessageViewController * messageView = [[MessageViewController alloc]init];</span><br><span class="line">/**</span><br><span class="line"> * UITabBarItem类实现一个项目在UITabBar对象.</span><br><span class="line"> * 也就是说UITabBar上的多个按钮其实就是UITabBarItem</span><br><span class="line"> *</span><br><span class="line"> * Title: tabBar上item的标题</span><br><span class="line"> * image: tabBar上item普通状态下的图片</span><br><span class="line"> * selectedImage: tabBar上item选中状态下的图片</span><br><span class="line"> * imageWithRenderingMode: item的图片始终绘制为原始状态</span><br><span class="line"> */</span><br><span class="line">UITabBarItem * messageItem = [[UITabBarItem alloc]initWithTitle:@&quot;消息&quot; image:[UIImage imageNamed:@&quot;message&quot;] selectedImage:[[UIImage imageNamed:@&quot;message_press&quot;] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]];</span><br><span class="line">//将设置好的item赋值给视图上的tabBarItem</span><br><span class="line">messageView.tabBarItem = messageItem;</span><br><span class="line">//创建一个导航栏对象，将视图对象作为导航栏的根控制器</span><br><span class="line">UINavigationController * navMessage = [[UINavigationController alloc]initWithRootViewController:messageView];</span><br><span class="line">//设置视图的导航栏标题</span><br><span class="line">messageView.navigationItem.title = @&quot;消息&quot;;</span><br><span class="line">//将导航栏对象作为子视图添加到TabBarController上</span><br><span class="line">[self addChildViewController:navMessage];</span><br><span class="line"></span><br><span class="line">//其他同理</span><br></pre></td></tr></table></figure><blockquote><p>拓展：也许会看得出，这样写代码的耦合性(代码重复性)很高，上面的代码是可以封装的，封装全文代码如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;TabBarViewController.h&quot;</span><br><span class="line">#import &quot;MessageViewController.h&quot;</span><br><span class="line">#import &quot;ContactViewController.h&quot;</span><br><span class="line">#import &quot;DynamicViewController.h&quot;</span><br><span class="line">@interface TabBarViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation TabBarViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [self setAllChildView];</span><br><span class="line">&#125;</span><br><span class="line">-(void)setAllChildView</span><br><span class="line">&#123;</span><br><span class="line">    //创建一个消息视图对象</span><br><span class="line">    MessageViewController * messageView = [[MessageViewController alloc]init];</span><br><span class="line">    [self addChildViewController:messageView tabBarItemTitle:@&quot;消息&quot; itemImgName:@&quot;message&quot; itemSelectedImgName:@&quot;message_press&quot;];</span><br><span class="line">    </span><br><span class="line">    //创建一个联系人视图对象</span><br><span class="line">    ContactViewController * contactView = [[ContactViewController alloc]init];</span><br><span class="line">    [self addChildViewController:contactView tabBarItemTitle:@&quot;联系人&quot; itemImgName:@&quot;contact&quot; itemSelectedImgName:@&quot;contact_press&quot;];</span><br><span class="line">    </span><br><span class="line">    //创建一个动态视图对象</span><br><span class="line">    DynamicViewController * dynamicView = [[DynamicViewController alloc]init];</span><br><span class="line">    [self addChildViewController:dynamicView tabBarItemTitle:@&quot;动态&quot; itemImgName:@&quot;dynamic&quot; itemSelectedImgName:@&quot;dynamic_press&quot;];</span><br><span class="line">&#125;</span><br><span class="line">-(void)addChildViewController:(UIViewController *)viewController tabBarItemTitle:(NSString *)title itemImgName:(NSString *)itemImgName itemSelectedImgName:(NSString *)itemSelectedImgName&#123;</span><br><span class="line">    /**</span><br><span class="line">     * UITabBarItem类实现一个项目在UITabBar对象.</span><br><span class="line">     * 也就是说UITabBar上的按钮其实就是多个UITabBarItem对象组成的</span><br><span class="line">     *</span><br><span class="line">     * Title: tabBar上item的标题</span><br><span class="line">     * image: tabBar上item普通状态下的图片</span><br><span class="line">     * selectedImage: tabBar上item选中状态下的图片</span><br><span class="line">     * imageWithRenderingMode: item的图片始终绘制为原始状态</span><br><span class="line">     */</span><br><span class="line">    UITabBarItem * messageItem = [[UITabBarItem alloc]initWithTitle:title image:[UIImage imageNamed:itemImgName] selectedImage:[[UIImage imageNamed:itemSelectedImgName] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]];</span><br><span class="line">    //将设置好的item赋值给视图上的tabBarItem</span><br><span class="line">    viewController.tabBarItem = messageItem;</span><br><span class="line">    //创建一个导航栏对象，将视图对象作为导航栏的根控制器</span><br><span class="line">    UINavigationController * navMessage = [[UINavigationController alloc]initWithRootViewController:viewController];</span><br><span class="line">    //设置视图的导航栏标题</span><br><span class="line">    viewController.navigationItem.title = title;</span><br><span class="line">    //将导航栏对象作为子视图添加到TabBarController上</span><br><span class="line">    [self addChildViewController:navMessage];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Demo地址: <a href="https://git.oschina.net/My_Ip/TabBarItem" target="_blank" rel="noopener">https://git.oschina.net/My_Ip/TabBarItem</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> iOS </tag>
            
            <tag> 原生 </tag>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>终端之间连接助手：Warp</title>
      <link href="/2018/07/21/%E7%BB%88%E7%AB%AF%E4%B9%8B%E9%97%B4%E8%BF%9E%E6%8E%A5%E5%8A%A9%E6%89%8B%EF%BC%9AWarp/"/>
      <url>/2018/07/21/%E7%BB%88%E7%AB%AF%E4%B9%8B%E9%97%B4%E8%BF%9E%E6%8E%A5%E5%8A%A9%E6%89%8B%EF%BC%9AWarp/</url>
      <content type="html"><![CDATA[<hr><a id="more"></a><blockquote><p>此篇是从简书移至本博客, 简书地址：<a href="https://www.jianshu.com/u/e79d7856d1ff" target="_blank" rel="noopener">https://www.jianshu.com/u/e79d7856d1ff</a><br>注：使用于Mac</p></blockquote><p>###第一步：安装，打开终端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install warp</span><br></pre></td></tr></table></figure></p><p>###第二步：使用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warp open</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/2007033-ef15d9bf096bcb93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对应的连接码"></p><blockquote><p>对方连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//rKdSNrp8r58f917y 就是对应的连接码</span><br><span class="line">warp connect rKdSNrp8r58f917y</span><br></pre></td></tr></table></figure></p></blockquote><p>###第三步：Help<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//warp 直接回车</span><br><span class="line">warp</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/2007033-a5916f38c57de028.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="帮助文档"></p><blockquote><p>open :创建、connect：连接、state：状态、authorize：授予权限、revoke：取消权限</p></blockquote><p>###第四步：状态 state<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//输入下面的命令直接回车</span><br><span class="line">warp state</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/2007033-d464a8d5626190d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="状态"></p><p>###第五步：授予权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//通过对应的主机名连接</span><br><span class="line">warp authorize mymac</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/2007033-35ffb0475f1e8784.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="授予权限"></p><p>###第六步：断开授权<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//两端都可以断开授权</span><br><span class="line">warp revoke mymac</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/2007033-52e763286cf7017d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="断开授权"></p><blockquote><p>一个好玩的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//连接之后直接输入下面代码，会读出你输入的东西</span><br><span class="line">say &apos;hello,world&apos;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Shell </tag>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>细谈浅析Mysql在Java项目中使用C3P0包和DBUtils对数据库的操作</title>
      <link href="/2018/07/21/%E7%BB%86%E8%B0%88%E6%B5%85%E6%9E%90Mysql%E5%9C%A8Java%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8C3P0%E5%8C%85%E5%92%8CDBUtils%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/07/21/%E7%BB%86%E8%B0%88%E6%B5%85%E6%9E%90Mysql%E5%9C%A8Java%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8C3P0%E5%8C%85%E5%92%8CDBUtils%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<hr><a id="more"></a><blockquote><p>  前言，本篇博客适合初学的java开发者阅读，了解一些底层的原理和思想。实际在工作中这些东西并不会再接触(除C3P0)，但是万变不离其宗！底层原理原理和思想非常重要！如需更正请详细指出，相互学习，感谢。</p></blockquote><h3 id="所需jar包"><a href="#所需jar包" class="headerlink" title="所需jar包"></a>所需jar包</h3><ol><li><p>要在Java项目中连接数据库，必须需要mysql驱动包.<br><img src="/images/mysql_cb/jar_1.png" alt="mysql驱动包"></p></li><li><p>C3P0.<br><img src="/images/mysql_cb/jar_2.png" alt="C3P0"></p></li><li><p>DBUtils.<br><img src="/images/mysql_cb/jar_3.png" alt="DBUtils"></p></li></ol><h3 id="原生五步法"><a href="#原生五步法" class="headerlink" title="原生五步法"></a>原生五步法</h3><blockquote><p>要使用Java代码连接数据库，并操作数据库，就要导入msyql包，原生操作数据库分为以下五步：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.注册驱动</span></span><br><span class="line">DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line"><span class="comment">// TODO 数据库路径</span></span><br><span class="line">String url = <span class="string">"jdbc:mysql://localhost:3306/shopmall"</span>;</span><br><span class="line"><span class="comment">// TODO 用户名与密码</span></span><br><span class="line">String user = <span class="string">"root"</span>;</span><br><span class="line">String password =<span class="string">"123"</span>;</span><br><span class="line"><span class="comment">// 2.获取连接</span></span><br><span class="line">Connection connection = (Connection) DriverManager.getConnection(url, user, password);</span><br><span class="line"><span class="comment">// 3.创建执行SQL语句的对象</span></span><br><span class="line">Statement statement = connection.createStatement();</span><br><span class="line">String sql = <span class="string">"select * from orders"</span>;</span><br><span class="line"><span class="comment">// 4.处理执行SQL语句的结果</span></span><br><span class="line">ResultSet result = statement.executeQuery(sql);</span><br><span class="line"><span class="keyword">while</span> (result.next()) &#123;</span><br><span class="line">    System.out.println(result.getObject(<span class="string">"ordertime"</span>) + <span class="string">"-"</span> + result.getObject(<span class="string">"address"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5.关闭资源</span></span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">    statement.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><blockquote><p><strong>第一步：</strong>     </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.注册驱动</span></span><br><span class="line">DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br></pre></td></tr></table></figure><p><strong>我们在register驱动时，是new Driver(); 但当我们进入到源码却发现，在静态代码块中已经注册了一次，此时会想，我们在写代码时已经注册了一次，再写一次相当于注册了两次，这样肯定是不合理的，根据源码我们可以发现DriverManage.registerDriver(new Driver); 是写在静态代码块中！那么怎么让这个静态代码块执行一次，不就注册了吗？而且是注册一次！这里牵扯到Java程序运行时先将.Java文件打包成.class文件，然后类加载器处理，所以我们这里只需要将msyql jar 包下的 Driver类加载一次就行了，代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>); <span class="comment">// 1.注册驱动</span></span><br></pre></td></tr></table></figure><p>mysql 包下Driver源码如下：<br><img src="/images/mysql_cb/path_1.png" alt="Driver类"></p><blockquote><p><strong>第二步：</strong>      </p></blockquote><p><strong>在配置连接MySQL参数时，直接是写在源码中，在实际开发中如果不使用框架也不会直接写在源码中，而会写在配置文件中，并将其封装成一个utils工具类。写入配置文件，即：.properties结尾的文件，示例如下：</strong></p><p><img src="/images/mysql_cb/path_2.png" alt="properties文件"></p><ul><li>注意事项：.properties配置文件中，可以理解为以键值对的形式书写、不能有空格、键值对直接必须以‘=’连接      </li></ul><p><strong>下面我给大家介绍两种实用的读取配置文件的方式：JDBCUtils是自己封装的一个工具类，蓝色标记处即为读取配置文件方式</strong></p><ul><li><p>方式一：通过I/O流读取，其中有直接通过传入相对路径文件和使用类加载器两种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driverClassName;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//从配置文件中读取这些成员变量的值，并设置好</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//让properties对象和jdbcinfo.properties文件发生关系</span></span><br><span class="line">        InputStream inStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*//第一种：将文件转换成字节输入流</span></span><br><span class="line"><span class="comment">            InputStream inStream = new FileInputStream("src/jdbcinfo.properties");*/</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//第二种:使用类加载器</span></span><br><span class="line">            <span class="comment">//1.获取类加载器对象</span></span><br><span class="line">            Class clazz = JDBCUtil.class;</span><br><span class="line">            ClassLoader classLoader = clazz.getClassLoader();</span><br><span class="line">            inStream = classLoader.getResourceAsStream(<span class="string">"jdbcinfo.properties"</span>);</span><br><span class="line">            <span class="comment">//将字节输入流加载到properties对象中</span></span><br><span class="line">            properties.load(inStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读取配置文件</span></span><br><span class="line">        password = properties.getProperty(<span class="string">"password"</span>);</span><br><span class="line">        user = properties.getProperty(<span class="string">"user"</span>);</span><br><span class="line">        url = properties.getProperty(<span class="string">"url"</span>);</span><br><span class="line">        driverClassName = properties.getProperty(<span class="string">"driverClassName"</span>);</span><br><span class="line">        <span class="comment">//1.注册驱动,在静态代码块中进行注册，防止了重复注册驱动。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(driverClassName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//2.获得连接</span></span><br><span class="line">        <span class="comment">//新创建一个连接</span></span><br><span class="line">        Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection conn,Statement statement,ResultSet resultSet)</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resultSet.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">            statement.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            conn.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方式二：使用ResourceBundle类，相比于I/O流还是简单一些</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String url;</span><br><span class="line">    <span class="keyword">static</span> String user;</span><br><span class="line">    <span class="keyword">static</span> String password;</span><br><span class="line">    <span class="keyword">static</span> String driver;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 读取配置文件</span></span><br><span class="line">        ResourceBundle bundle = ResourceBundle.getBundle(<span class="string">"jdbc"</span>);</span><br><span class="line">        url = bundle.getString(<span class="string">"url"</span>);</span><br><span class="line">        user = bundle.getString(<span class="string">"user"</span>);</span><br><span class="line">        password = bundle.getString(<span class="string">"password"</span>);</span><br><span class="line">        driver = bundle.getString(<span class="string">"driver"</span>);</span><br><span class="line">        System.out.println(url + user + password + driver);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(driver);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获得连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(ResultSet resultSet, Statement statement, Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resultSet.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">            statement.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>第三步：</strong>   </p></blockquote><p><strong>在将注册驱动、读取配置文件和获取连接封装成一个工具类之后再看一下连接、操作数据库的代码，这里有个SQL语句注入的问题，所以我将Statement改成类PreparedStatement。PreparedStatement是先记住了SQL语句的格式，然后再通过setString方式传入参数，而传入参数是以1开始：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCDemo01</span> </span>&#123; </span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.注册驱动:无需再写</span></span><br><span class="line">        <span class="comment">//2.获得连接对象</span></span><br><span class="line">        Connection conn = JDBCUtil.getConnection();</span><br><span class="line">        String sql = <span class="string">"select * from orders where oid=?"</span>;</span><br><span class="line">        <span class="comment">//3.创建执行SQL语句的对象</span></span><br><span class="line">        PreparedStatement prepareStatement = conn.prepareStatement(sql);</span><br><span class="line">                prepareStatement.setString(<span class="number">1</span>,<span class="string">"1"</span>);</span><br><span class="line">        <span class="comment">//4.执行SQL语句,如果有结果集则处理结果集</span></span><br><span class="line">        ResultSet resultSet = prepareStatement.executeQuery();</span><br><span class="line">        <span class="keyword">while</span>(resultSet.next())&#123;</span><br><span class="line">            System.out.println(result.getObject(<span class="string">"ordertime"</span>) + <span class="string">"-"</span> + result.getObject(<span class="string">"address"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.关闭资源</span></span><br><span class="line">        JDBCUtil.close(conn, prepareStatement, resultSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h3><blockquote><p>这个jar包是对连接数据的一个优化库，内部主要重点是连接池的概念，对连接数据库、操作数据库在性能上有了一定的提升.</p></blockquote><ol><li>相信C3P0是大多数Java程序员操作数据库所使用的第一个jar包吧，<strong>c3p0包中重点是理解连接池的概念</strong>。在操作数据库中，sun公司制定了一套规范，说白了就是接口，c3p0就是实现了DataSource接口。</li><li>在不是用c3p0包会出现什么问题呢？ 每次操作数据库都要获取一个连接对象吗？ 假如有10万个用户同时访问数据库，我们需要同时创建10万个connection吗？显然是NO！！！所以就有了连接池的概念，在程序运行时就创建若干个连接对象并放入集合中（LinkedList集合），当我们需要使用时就从集合中拿到第一个连接对象（connection），用完后就还回到集合中（addLast()），这样就大大的减少了内存提高了性能。这时会有一个问题，当访问数大于连接池的count时，What do I do？这时我们就设置一个等待时间，当等待时间都过去了就重新获取一个新的连接，这样就解决了。</li><li><strong>C3P0里面还使用了一个设计模式：装饰者模式</strong></li><li><strong>在使用C3P0时，有两种方式，一种也是通过配置文件读取连接数据库的参数，另一种是写一个c3p0-config.xml文件，c3p0内部会自己解析此文件：</strong><ul><li>方式一：通过配置文件读取连接数据库的参数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C3P0Util</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException, PropertyVetoException</span>&#123;</span><br><span class="line">        <span class="comment">//从C3P0连接池对象中获取连接</span></span><br><span class="line">        <span class="comment">//1.创建c3p0连接池对象</span></span><br><span class="line">         ComboPooledDataSource cpds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">        <span class="comment">// 读取配置文件</span></span><br><span class="line">        ResourceBundle bundle = ResourceBundle.getBundle(<span class="string">"jdbc"</span>);</span><br><span class="line">        String url = bundle.getString(<span class="string">"url"</span>);</span><br><span class="line">        String user = bundle.getString(<span class="string">"user"</span>);</span><br><span class="line">        String password = bundle.getString(<span class="string">"password"</span>);</span><br><span class="line">        String driver = bundle.getString(<span class="string">"driver"</span>);</span><br><span class="line">         <span class="comment">//配置连接池，要将用户名、密码、url等等设置一下</span></span><br><span class="line">         cpds.setUser(user);</span><br><span class="line">         cpds.setInitialPoolSize(<span class="number">10</span>);</span><br><span class="line">         cpds.setPassword(password);</span><br><span class="line">         cpds.setJdbcUrl(url);</span><br><span class="line">         <span class="comment">//设置驱动类的类名</span></span><br><span class="line">         cpds.setDriverClass(driver);</span><br><span class="line">        <span class="comment">//2.从这个连接池对象中获取连接</span></span><br><span class="line">         Connection connection = cpds.getConnection();</span><br><span class="line">         <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet resultSet,Statement statement,Connection connection)</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resultSet.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">            statement.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li>方式二：配置c3p0-config.xml文件，这里我是直接写死在xml中，工作中推荐把这些配置信息单独写到一个.properties文件中<br><img src="/images/mysql_cb/path_3.png" alt="配置c3p0-config.xml文件"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C3P0Utils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  ComboPooledDataSource dataSource;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">         <span class="comment">//从C3P0连接池中获取连接对象</span></span><br><span class="line">        dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException, PropertyVetoException</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> dataSource.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet resultSet,Statement statement,Connection connection)</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resultSet.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">            statement.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="DBUtils"><a href="#DBUtils" class="headerlink" title="DBUtils"></a>DBUtils</h3><blockquote><p>DBUtils 主要功能是减少了使用JDBC对SQL数据操作的代码，这里仅仅是对代码的优化，在性能上没有提升，DBUtils内部实现原理使用到了反射机制. 对于DBUtils的使用，内部核心我认为是<strong>反射机制和内省机制</strong>，大家可以去了解一个反射机制与内省机制，你也可以写一个DBUtils出来！这篇博客先贴出如何使用DBUtils包（这里需要与刚刚封装的C3P0Utils类一起使用)    </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">    <span class="comment">//从t_user表中删除id=6的数据</span></span><br><span class="line">    <span class="comment">//1.创建QueryRunner对象,传入一个连接池对象</span></span><br><span class="line">    QueryRunner runner = <span class="keyword">new</span> QueryRunner(C3P0Util.getDataSource());</span><br><span class="line">    <span class="comment">//2.创建并执行SQL语句</span></span><br><span class="line">    String sql = <span class="string">"delete from t_user where id=?"</span>;</span><br><span class="line">    runner.update(sql, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">    <span class="comment">//更新id为2的数据的密码为888888</span></span><br><span class="line">    <span class="comment">//1.创建QueryRunner对象</span></span><br><span class="line">    QueryRunner runner = <span class="keyword">new</span> QueryRunner(C3P0Util.getDataSource());</span><br><span class="line">    <span class="comment">//2.创建并执行SQL语句</span></span><br><span class="line">    String sql = <span class="string">"update t_user set password=? where id=?"</span>;</span><br><span class="line">    Object[] params = &#123;<span class="string">"888888"</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    runner.update(sql, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">    <span class="comment">//查询id为2的数据，并将该条数据存放到user对象中</span></span><br><span class="line">    <span class="comment">//1.创建QueryRunner对象</span></span><br><span class="line">    QueryRunner runner = <span class="keyword">new</span> QueryRunner(C3P0Util.getDataSource());</span><br><span class="line">    <span class="comment">//2.创建并执行SQL语句</span></span><br><span class="line">    String sql = <span class="string">"select * from t_user where id=?"</span>;</span><br><span class="line">    <span class="comment">//第一种ResultSetHandler接口的实现类，叫做BeanHandler能够将一条数据封装到JavaBean对象中</span></span><br><span class="line">    <span class="comment">//要求这个JavaBean对象的成员变量的变量名和这条数据的字段名一模一样</span></span><br><span class="line">    <span class="comment">//你要将这条数据封装到哪个JavaBean对象中，就传入该类的字节码文件对象</span></span><br><span class="line">    User user = runner.query(sql, <span class="keyword">new</span> BeanHandler&lt;&gt;(User.class), <span class="number">2</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">    <span class="comment">//查询出t-user表中的所有数据，并将每一条数据存放到user对象中，再将每一个user对象存放list集合中</span></span><br><span class="line">    <span class="comment">//1.创建QueryRunner对象</span></span><br><span class="line">    QueryRunner runner = <span class="keyword">new</span> QueryRunner(C3P0Util.getDataSource());</span><br><span class="line">    <span class="comment">//2.创建并执行SQL语句</span></span><br><span class="line">    String sql = <span class="string">"select * from t_user"</span>;</span><br><span class="line">    <span class="comment">//处理多条数据，将每条数据存放到JavaBean对象中，然后将每个JavaBean对象存放到list集合中，就使用BeanListHandler</span></span><br><span class="line">    List&lt;User&gt; users = runner.query(sql, <span class="keyword">new</span> BeanListHandler&lt;&gt;(User.class));</span><br><span class="line">    System.out.println(users.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Java </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring框架简介</title>
      <link href="/2018/07/20/Spring%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/"/>
      <url>/2018/07/20/Spring%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<hr><a id="more"></a><blockquote><p>  前言，对Spring框架的一些总结</p></blockquote><h3 id="spring框架的特征"><a href="#spring框架的特征" class="headerlink" title="spring框架的特征"></a>spring框架的特征</h3><ol><li>轻量级</li><li>IOC(控制反转思想),非侵入式</li><li>AOP(面向切面编程思想)</li><li>容器/工厂</li></ol><h3 id="谈谈对spring的理解"><a href="#谈谈对spring的理解" class="headerlink" title="谈谈对spring的理解"></a>谈谈对spring的理解</h3><ul><li>spring是一个开源框架，为简化企业级应用开发而生</li><li>spring可以<strong>使用简单的javaBean</strong>实现只有EJB才能实现的功能</li><li>spring是一个<strong>IOC(控制反转)</strong>和<strong>AOP(面向切面编程)</strong>容器框架</li><li>方便解耦，简化开发<ul><li>spring就是一个大工厂，可以将所有对象创建和依赖关系维护，交给spring管理，AOP编程的支持</li></ul></li><li>AOP编程支持<ul><li>spring提供面向切面编程，可以方便的实现对程序进行权限拦截，运行监控等功能</li></ul></li><li>方便程序测试<ul><li>spring对Junit4支持，可以通过注解方便测试</li></ul></li><li>方便集成各种优秀框架<ul><li>spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持(MyBatis、Struts、Hibernate….)</li></ul></li><li>声明式事物的支持<ul><li>只需要通过配置就可以完成对事物的管理，无需手动编程</li></ul></li></ul><h3 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h3><blockquote><p> 1.<strong>spring 核心容器的最基本jar包</strong></p></blockquote><ul><li><strong>Beans</strong><ul><li>spring-beans-4.2.4.RELEASE.jar</li></ul></li><li><strong>Core</strong><ul><li>spring-context-4.2.4.RELEASE.jar</li></ul></li><li><strong>Context</strong><ul><li>spring-core-4.2.4.RELEASE.jar</li></ul></li><li><strong>Expression Language</strong><ul><li>spring-expression-4.2.4.RELEASE.jar</li></ul></li></ul><blockquote><p>  2.spring框架所需的日志包</p></blockquote><ul><li>默认采用apache commons-logging(JCL)日志框架+log4j的日志实现，还需要添加log4j的配置文件。 </li></ul><h3 id="控制反转-IOC-inversion-of-control"><a href="#控制反转-IOC-inversion-of-control" class="headerlink" title="控制反转 IOC (inversion of control)"></a>控制反转 IOC (inversion of control)</h3><ul><li>传统的java开发模式中，当需要一个对象时，我们会自己使用<u><strong>new</strong></u> 或者 <strong><u>getInstance</u></strong>等直接或间接调用高中方法创建对象。而在spring开发模式中，spring容器使用了<strong><u>工厂模式</u></strong>为我们创建了所需要的对象，不需要我们自己创建，直接调用spring提供的对象即可，这就是<strong>控制反转思想。也就是将对象创建权反转给spring，解决程序的耦合性(传统的java开中，service层与dao层关联依赖过多，导致耦合性大大的增加)。由spring创建对象的过程,就是IOC</strong></li></ul><blockquote><p>  创建spring的核心配置文件 <strong>applicationContext.xml</strong></p></blockquote><ul><li>引入约束</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在beans中配置DAO or Service….其他Bean</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">   IOC:控制反转</span></span><br><span class="line"><span class="comment">   bean: spring工厂帮你new的一个对象(反射机制)</span></span><br><span class="line"><span class="comment">   id/name: 标识对象的名称, 通过该名称来获取bean对象</span></span><br><span class="line"><span class="comment">   class: 要new对象类的全限定名</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user_dao"</span> <span class="attr">class</span>=<span class="string">"com.jason.spring.dao.impl.UserDaoImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user_service"</span> <span class="attr">class</span>=<span class="string">"com.jason.spring.service.impl.UserServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO 创建Spring的工厂, 加载applicationContext.xml配置文件</span></span><br><span class="line">    ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    <span class="comment">// TODO 通过标识对象的名称获得实例</span></span><br><span class="line">    IUserDao dao = (IUserDao) ac.getBean(<span class="string">"user_dao"</span>);</span><br><span class="line">    <span class="comment">// TODO 调用方法</span></span><br><span class="line">    dao.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖注入-DI-Dependency-Injection"><a href="#依赖注入-DI-Dependency-Injection" class="headerlink" title="依赖注入 DI (Dependency Injection )"></a>依赖注入 DI (Dependency Injection )</h3><ul><li><p><strong>spring使用JavaBean对象的set方法或者构造函数为我们在创建所需对象时将其属性自动设置所需要值的过程，就是依赖注入思想</strong></p></li><li><p>在业务层中定义一个dao层属性，并添加set方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IUserDao userDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(IUserDao dao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = dao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHelloService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置spring容器</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">  DI:依赖注入:由spring创建对象时，将一个对象注入到另一个对象的过程就是DI</span></span><br><span class="line"><span class="comment">  property: 属性注入</span></span><br><span class="line"><span class="comment">   name: 表示set方法的名称</span></span><br><span class="line"><span class="comment">   ref: 表示spring容器创建对象的表示名称，进行注入，表示对象的注入</span></span><br><span class="line"><span class="comment">   value: 表示值的注入</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user_service"</span> <span class="attr">class</span>=<span class="string">"com.jason.spring.service.impl.UserServiceImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDao"</span> <span class="attr">ref</span>=<span class="string">"user_dao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO 依赖注入</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    IUserService service = (IUserService) ac.getBean(<span class="string">"user_service"</span>);</span><br><span class="line">    service.sayHelloService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IOC-与-DI-的区别"><a href="#IOC-与-DI-的区别" class="headerlink" title="IOC 与 DI 的区别"></a>IOC 与 DI 的区别</h3><ul><li>IOC : 控制反转，将对象的创建权交给spring;</li><li>DI : 依赖注入，在spring创建这个类的过程中，把这个类所依赖的属性设置进来;</li></ul><h3 id="spring的工厂类"><a href="#spring的工厂类" class="headerlink" title="spring的工厂类"></a>spring的工厂类</h3><blockquote><ul><li><strong>BeanFactory</strong> with <strong>ApplicationContext</strong></li></ul></blockquote><ol><li><strong>BeanFactory 是早期spring提供的工厂类</strong></li><li><strong>ApplicationContext是目前版本提供的工厂类</strong></li><li>ApplicationContext的功能比BeanFactory功能多<ul><li><em>BeanFactory在调用getBean()方法时才会生成类的实例</em></li><li><em>ApplicationContext在加载spring配置文件的时候生成类的实例</em></li></ul></li></ol><blockquote><ul><li>ApplicationContext的实现类的区别</li></ul></blockquote><ol><li><strong>ClassPathXmlApplicationContext</strong><ol><li>加载的是类路径(src)下的spring配置文件</li></ol></li><li><em>FileSystemXMLApplicationContext</em><ol><li>加载的是文件系统下的配置文件(磁盘路径)</li></ol></li></ol><ul><li><strong>Question</strong></li></ul><ol><li>为什么不直接使用顶级接口对象来操作<ol><li>BeanFactory采用延迟加载，第一次getBean时才会初始化Bean</li><li>BeanFactory的用法：<ol><li>BeanFactory ac = new <del>XmlBeanFactory</del>(new CalssPathResource(“application.xml”));</li><li>BeanFactory ac = new <del>XmlBeanFactory</del>(new  FileSystemResource(“D:\applicationContext.xml”)); </li></ol></li><li>ApplicationContext是对BeanFactory扩展，提供更多地功能<ol><li>国际化处理</li><li>事件传递</li><li>Bean自动装配</li><li>各种不同应用层的Context的实现</li></ol></li></ol></li><li>由此可见，ApplicationContext 更加强大。so，现在开发基本没人用BeanFactory</li></ol><ul><li><em>show code</em></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSpring</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//构建spring工厂</span></span><br><span class="line">    <span class="comment">//ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");</span></span><br><span class="line">    <span class="comment">//使用BeanFactory</span></span><br><span class="line">    <span class="comment">//BeanFactory applicationContext = new XmlBeanFactory(new ClassPathResource("applicationContext.xml"));</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//直接使用超级接口</span></span><br><span class="line">    BeanFactory applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    IUserService userService=(IUserService) applicationContext.getBean(<span class="string">"userService"</span>);</span><br><span class="line">    userService.login();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spring相关配置"><a href="#spring相关配置" class="headerlink" title="spring相关配置"></a>spring相关配置</h3><ul><li><p>bean中 id 与 name 的配置</p><ul><li><em>id 中不能出现特殊字符</em></li><li><em>name中可以出现特殊字符</em><ul><li>name中可以指定多个标识符(第一个为标识符，其余的为别名，若指定了id，id则为标识符，name中的为别名)</li><li>name中的标识符可以使用 ‘,’  ‘;’  ‘ ‘(逗号，分号，空格)分隔开</li></ul></li></ul></li><li><p>bean的作用访问配置：<strong><em>scope的配置</em></strong></p><ul><li>spring创建类时，默认采用单例模式进行创建，如果想改变单例模式，需要通过scope属性设置</li><li>scope属性的取值：<ul><li>singleton : 默认值，单例</li><li>prototyep : 多例的</li><li>request、session、globalsession，分别是将创建的对象存到request、session、全局的session中</li></ul></li></ul></li><li><p>bean的生命周期配置</p><ul><li><p>创建Bean.java</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bean的构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bean被初始化了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bean被销毁了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>spring容器下bean中配置</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring的Bean的作用范围的配置============ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean1"</span> <span class="attr">class</span>=<span class="string">"com.itheima.spring.demo2.Bean1"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span> <span class="attr">init-method</span>=<span class="string">"setup"</span> <span class="attr">destroy-method</span>=<span class="string">"destroy"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span></span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>spring的分模块开发的配置</p><ul><li><p>在加载配置文件时，加载多个配置文件</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span>  ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>, <span class="string">"applicationContext2.xml"</span>);</span><br></pre></td></tr></table></figure></li><li><p>在配置文件中引入其他配置文件</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"applicationContext_2.xml"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Use the terminal to create Maven projects</title>
      <link href="/2018/07/19/Use-the-terminal-to-create-Maven-projects/"/>
      <url>/2018/07/19/Use-the-terminal-to-create-Maven-projects/</url>
      <content type="html"><![CDATA[<hr><a id="more"></a><blockquote><p>  前言，在终端(命令行)使用mvn命令创建Maven Project.</p></blockquote><h3 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h3><ul><li>mvn –v (mvn -version)</li></ul><p><img src="/images/mvn/path_1.png" alt="mav-version"></p><h3 id="maven创建java项目"><a href="#maven创建java项目" class="headerlink" title="maven创建java项目"></a>maven创建java项目</h3><ul><li>mvn archetype:generate -DgroupId=com.java_demo -DartifactId=java_demo</li></ul><h3 id="maven创建web项目"><a href="#maven创建web项目" class="headerlink" title="maven创建web项目"></a>maven创建web项目</h3><ul><li>mvn archetype:generate -DgroupId=com.web_demo -DartifactId=web_demo -DarchetypeArtifactId=maven-archetype-webapp<ul><li>archetype：原型插件</li><li>DgroupId：一般填写公司域名后缀倒过来</li><li>DartifactId：项目名</li><li>DarchetypeArtifactId：web项目的模板</li></ul></li><li>mvn archetype:create -DgroupId=com.web_demo -DartifactId=web_demo -DarchetypeArtifatId=maven-archetype-webapp<ul><li><strong><em>注意事项</em></strong>：3.5版本以上丢弃掉create方式创建maven项目，使用generate。所以上面一种是3.5以上的创建方式，这种是3.5以下的。</li></ul></li></ul><h3 id="创建和导入-IntelliJ-IDEA或Eclipse"><a href="#创建和导入-IntelliJ-IDEA或Eclipse" class="headerlink" title="创建和导入(IntelliJ IDEA或Eclipse)"></a>创建和导入(IntelliJ IDEA或Eclipse)</h3><ul><li>第一步：将创建项目命令复制到终端</li></ul><p><img src="/images/mvn/path_2.png" alt="2"></p><ul><li>第二步：执行第一步之后，中间若出现需要填什么直接回车，最后会出现BUILD SUCCESS则创建成功了</li></ul><p><img src="/images/mvn/path_3.png" alt="3"></p><ul><li>第三步：Import Project</li></ul><ol><li>Import Project<br><img src="/images/mvn/path_4.png" alt="4"></li><li>选择创建好的项目<br><img src="/images/mvn/path_4_1.png" alt="4-1"></li><li>下一步<br><img src="/images/mvn/path_4_2.png" alt="4-2"></li><li>选择jdk,然后next -&gt; finish<br><img src="/images/mvn/path_4_3.png" alt="4-3"></li><li>完成<br><img src="/images/mvn/path_5.png" alt="5"></li></ol>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Shell </tag>
            
            <tag> Java </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>定时任务调度工具之Timer</title>
      <link href="/2018/07/18/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B7%A5%E5%85%B7%E4%B9%8BTimer/"/>
      <url>/2018/07/18/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B7%A5%E5%85%B7%E4%B9%8BTimer/</url>
      <content type="html"><![CDATA[<hr><a id="more"></a><blockquote><p>  前言，本文主要对Timer类的介绍以及API的使用详情</p></blockquote><h3 id="是什么是定时任务调度？"><a href="#是什么是定时任务调度？" class="headerlink" title="是什么是定时任务调度？"></a>是什么是定时任务调度？</h3><blockquote><p>  基于给定的时间点、给定的时间间隔或者给定的执行次数自动执行任务。<br>  Timer 由JDK自带提供！</p></blockquote><h3 id="Timer的定义"><a href="#Timer的定义" class="headerlink" title="Timer的定义"></a>Timer的定义</h3><blockquote><p>  有且仅有一个后台线程对多个业务线程进行定时定频率的调度</p></blockquote><h3 id="Timer定时调度任务的四种用法"><a href="#Timer定时调度任务的四种用法" class="headerlink" title="Timer定时调度任务的四种用法"></a>Timer定时调度任务的四种用法</h3><p><strong>首先，创建一个MyTimerTask类，继承TimerTask</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTimerTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTimerTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"current name is "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.<strong>schedule(task, time) : 在时间等于或者超过time的时候执行，且执行一次task。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Timer实例</span></span><br><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"><span class="comment">// 创建一个TimerTask实例</span></span><br><span class="line">MyTimerTask task = <span class="keyword">new</span> MyTimerTask(<span class="string">"s1"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在时间等于或者超过time的时候执行，且执行一次task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"><span class="comment">// 在当前时间的5秒后执行该任务</span></span><br><span class="line">calendar.add(Calendar.SECOND, <span class="number">5</span>);</span><br><span class="line">timer.schedule(task, calendar.getTime());</span><br></pre></td></tr></table></figure></p><p>2.<strong>schedule(task, time, period) : 在时间等于或者超过time的时候首次执行task，之后每隔period毫秒重复执行task</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Timer实例</span></span><br><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"><span class="comment">// 创建一个TimerTask实例</span></span><br><span class="line">MyTimerTask task = <span class="keyword">new</span> MyTimerTask(<span class="string">"s2"</span>);</span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在时间等于或者超过time的时候首次执行task，之后每隔period毫秒重复执行task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">timer.schedule(task, calendar.getTime(), <span class="number">3000</span>);</span><br></pre></td></tr></table></figure></p><p>3.<strong>schedule(task, delay) : 等待delay毫秒后执行且执行一次task</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Timer实例</span></span><br><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"><span class="comment">// 创建一个TimerTask实例</span></span><br><span class="line">MyTimerTask task = <span class="keyword">new</span> MyTimerTask(<span class="string">"s3"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待delay毫秒后执行且执行一次task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">timer.schedule(task, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure></p><p>4.<strong>schedule(task, delay, period) : 等待等于或者超过delay毫秒后首次执行task 之后每隔period毫秒重复执行task</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Timer实例</span></span><br><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"><span class="comment">// 创建一个TimerTask实例</span></span><br><span class="line">MyTimerTask task = <span class="keyword">new</span> MyTimerTask(<span class="string">"小米"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待delay毫秒后首次执行task 之后每隔period毫秒重复执行task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">timer.schedule(task, <span class="number">3000</span>, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure></p><h3 id="scheduleAtFixedRate的两种用法"><a href="#scheduleAtFixedRate的两种用法" class="headerlink" title="scheduleAtFixedRate的两种用法"></a>scheduleAtFixedRate的两种用法</h3><p>1.<strong>scheduleAtFixedRate(TimerTask task, Date firstTime, long period) : 时间等于或者超过time的时候首次执行task，之后每隔period毫秒重复执行task</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Timer实例</span></span><br><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"><span class="comment">// 创建一个TimerTask实例</span></span><br><span class="line">MyTimerTask task = <span class="keyword">new</span> MyTimerTask(<span class="string">"scheduleAtFixedRate1"</span>);</span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 时间等于或者超过time的时候首次执行task，之后每隔period毫秒重复执行task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">timer.scheduleAtFixedRate(task, calendar.getTime(), <span class="number">2000</span>);</span><br></pre></td></tr></table></figure></p><p>2.<strong>scheduleAtFixedRate(TimerTask task, long delay, long period):等待等于或者超过delay毫秒后首次执行task 之后每隔period毫秒重复执行task</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Timer实例</span></span><br><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"><span class="comment">// 创建一个TimerTask实例</span></span><br><span class="line">MyTimerTask task = <span class="keyword">new</span> MyTimerTask(<span class="string">"scheduleAtFixedRate2"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待等于或者超过delay毫秒后首次执行task 之后每隔period毫秒重复执行task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">timer.scheduleAtFixedRate(task, <span class="number">3000</span>, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure></p><h3 id="TimerTask其他函数介绍"><a href="#TimerTask其他函数介绍" class="headerlink" title="TimerTask其他函数介绍"></a>TimerTask其他函数介绍</h3><ul><li><p><strong>cancel() 取消当前TimerTask中的任务</strong></p></li><li><p><strong>scheduleExecutionTime() 返回此任务实际执行的已安排的执行时间</strong></p></li></ul><h3 id="Timer其他函数介绍"><a href="#Timer其他函数介绍" class="headerlink" title="Timer其他函数介绍"></a>Timer其他函数介绍</h3><ul><li><strong>cancel() 终止此定时器，丢弃所有当前已安排的任务</strong></li><li><strong>int purge() 从此计时器的任务队列中移除所有==已取消==的任务，返回值是从队列中移除的任务数</strong></li></ul><h3 id="Timer的缺陷"><a href="#Timer的缺陷" class="headerlink" title="Timer的缺陷"></a>Timer的缺陷</h3><ul><li>管理并发任务的缺陷<ul><li>Timer有且只有一个线程去执行定时任务，如果存在多个任务且任务时间过长，会导致预期效果与实际效果不符</li></ul></li><li>当任务抛出异常时的缺陷<ul><li>如果TimerTask在执行时，抛出RuntimeException异常，Timer会停止所有任务的执行</li></ul></li><li>不推荐使用的场景<ul><li>对时效性要求较高的多任务并发</li><li>对复杂任务的调度</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Java </tag>
            
            <tag> Code </tag>
            
            <tag> Timer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>阿里云服务器搭建以及Linux安装软件小结</title>
      <link href="/2018/07/18/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8ALinux%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%B0%8F%E7%BB%93/"/>
      <url>/2018/07/18/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8ALinux%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<hr><a id="more"></a><blockquote><p>  前言，总结一下对阿里云服务器的配置以及Linux命令的简单使用</p></blockquote><h5 id="购买"><a href="#购买" class="headerlink" title="购买"></a>购买</h5><blockquote><p><strong>首先，在阿里云官网购买云服务器ESC</strong> (<a href="https://promotion.aliyun.com/ntms/campus2017.html?spm=5176.8142029.631162.75.68606d3e9rbcEa" target="_blank" rel="noopener">https://promotion.aliyun.com/ntms/campus2017.html?spm=5176.8142029.631162.75.68606d3e9rbcEa</a>) 。这个网址是学生优惠，非常划算！</p></blockquote><p><img src="https://toolife.github.io/images/ali_cloud/path_1.png" alt="path_1"></p><h5 id="配置密码"><a href="#配置密码" class="headerlink" title="配置密码"></a>配置密码</h5><blockquote><p><strong>配置连接(登录)服务器密码、设置远程连接密码</strong></p></blockquote><p><img src="https://toolife.github.io/images/ali_cloud/path_2.png" alt="path_2"></p><h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><blockquote><p>  <strong>购买好云服务器，设置好密码之后，再远程连接云服务器 ( 我服务器镜像是Linux Center OS 7.3 64位 )，点击远程连接，就跳转到了一个命令行窗口.</strong></p></blockquote><p><img src="https://toolife.github.io/images/ali_cloud/path_3.png" alt="path_3"></p><p><img src="https://toolife.github.io/images/ali_cloud/path_4.png" alt="path_4"></p><p>连接…..</p><p><img src="https://toolife.github.io/images/ali_cloud/path_6.png" alt="path_6"></p><ul><li>也可以通过<strong>SecureCRT</strong>客户端连接，或者<strong>本机终端连接</strong></li></ul><p><img src="https://toolife.github.io/images/ali_cloud/path_8.png" alt="SecureCRT客户端"></p><h5 id="推荐一个好用的插件：fish"><a href="#推荐一个好用的插件：fish" class="headerlink" title="推荐一个好用的插件：fish"></a>推荐一个好用的插件：fish</h5><blockquote><p>  优点：让你的命令行具有提示功能，还能记录你输入过得命令。缺点就是有些命令识别不了，需要退出fish模式下再执行😆</p></blockquote><p><img src="https://toolife.github.io/images/ali_cloud/path_7.png" alt="path_7"></p><h5 id="阿里云服务器防火墙与端口"><a href="#阿里云服务器防火墙与端口" class="headerlink" title="阿里云服务器防火墙与端口"></a>阿里云服务器防火墙与端口</h5><blockquote><p>  阿里云服务器信息</p><p>  Linux Center OS 7.3 x86_64</p><p>  <strong>前言，Center OS 7.0 以后默认使用的是firewall作为防火墙，而Center OS 7.0以前，使用 iptables 作为防火墙，所以我们在开启、关闭、刷新服务以及打开端口都变了，使用systemctl命令。systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体</strong></p></blockquote><p>1.firewalld的基本使用<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">启动: systemctl start firewalld</span><br><span class="line">关闭: systemctl stop firewalld</span><br><span class="line">查看状态: systemctl status firewalld </span><br><span class="line">开机禁用: systemctl disable firewalld</span><br><span class="line">开机启用: systemctl enable firewalld</span><br></pre></td></tr></table></figure></p><p>2.配置firewalld-cmd<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">查看版本: firewall-cmd --version</span><br><span class="line">查看帮助: firewall-cmd --help</span><br><span class="line">显示状态: firewall-cmd --state</span><br><span class="line">查看所有打开的端口: firewall-cmd --zone=public --list-ports</span><br><span class="line">更新防火墙规则: firewall-cmd --reload</span><br><span class="line">查看区域信息: firewall-cmd --get-active-zones</span><br><span class="line">查看指定接口所属区域: firewall-cmd --get-zone-of-interface=eth0</span><br><span class="line">拒绝所有包:firewall-cmd --panic-on</span><br><span class="line">取消拒绝状态: firewall-cmd --panic-off</span><br><span class="line">查看是否拒绝: firewall-cmd --query-panic</span><br></pre></td></tr></table></figure></p><p>3.systemctl命令介绍<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">启动一个服务：systemctl start firewalld.service</span><br><span class="line">关闭一个服务：systemctl stop firewalld.service</span><br><span class="line">重启一个服务：systemctl restart firewalld.service</span><br><span class="line">显示一个服务的状态：systemctl status firewalld.service</span><br><span class="line">在开机时启用一个服务：systemctl enable firewalld.service</span><br><span class="line">在开机时禁用一个服务：systemctl disable firewalld.service</span><br><span class="line">查看服务是否开机启动：systemctl is-enabled firewalld.service</span><br><span class="line">查看已启动的服务列表：systemctl list-unit-files|grep enabled</span><br><span class="line">查看启动失败的服务列表：systemctl --failed</span><br></pre></td></tr></table></figure></p><p>4.开启、查看、关闭端口<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开放<span class="number">80</span>端口：firewall-cmd --zone=public --add-port=<span class="number">80</span>/tcp --permanent</span><br><span class="line">查看<span class="number">80</span>端口是否开放：firewall-cmd --zone= public --query-port=<span class="number">80</span>/tcp</span><br><span class="line">关闭<span class="number">80</span>端口：firewall-cmd --zone= public --remove-port=<span class="number">80</span>/tcp --permanent</span><br><span class="line">重新载入：firewall-cmd --reload</span><br></pre></td></tr></table></figure></p><p>5.既然端口已经打开了，然而还是访问不了！！！<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://x.x.x.x:80</span></span><br></pre></td></tr></table></figure></p><p>6.在阿里云本实例安全组中，添加安全组规则<br><img src="https://toolife.github.io/images/ali_cloud/path_9.png" alt="path_9"></p><p>7.再次访问还是访问不了，原因是：缺少Apache服务，接下来安装<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">安装：yum install httpd httpd-devel</span><br><span class="line">设置开机自启：chkconfig --levels <span class="number">235</span> httpd on</span><br><span class="line">开启Apache服务：systemctl start httpd</span><br><span class="line"></span><br><span class="line">再次访问 http://x.x.x.x:<span class="number">80</span>，ok了</span><br></pre></td></tr></table></figure></p><p><img src="https://toolife.github.io/images/ali_cloud/path_10.png" alt="path_10"></p><h5 id="安装JDK、Tomcat"><a href="#安装JDK、Tomcat" class="headerlink" title="安装JDK、Tomcat"></a>安装JDK、Tomcat</h5><blockquote><p>  <strong>安装前言，在阿里云服务器安装JDK、Tomcat的一系列Bug。在我个人的本机上使用的是Center OS 6.4 ，这里使用的是iptables作为防火墙。但安装程序都是一样的，期间肯定会出现Bug。come on，一步一步来安装JDK与Tomcat。</strong></p></blockquote><h6 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h6><p>1.先准备好Linux下JDK安装包 (jdk-8u171-linux-i586.tar)<br>2.检查系统上是否安装了jdk(若安装了就需要先卸载再使用我们自己的)<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure></p><p>3.查看出安装的java的软件包<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep java</span><br></pre></td></tr></table></figure></p><p>4.卸载jdk<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps java-1.6.0-openjdk-1.6.0.0-1.66.1.13.0.el6.i686</span><br><span class="line">rpm -e --nodeps java-1.7.0-openjdk-1.7.0.45-2.4.3.3.el6.i686 tzdata-java-2013g-1.el6.noarch</span><br></pre></td></tr></table></figure></p><p>5.在 /usr/local 新建一个文件夹 java,存放jdk<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/java</span><br></pre></td></tr></table></figure></p><p>6.移动 jdk-8u171-linux-i586.tar 到 /usr/local/java下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv jdk-8u171-linux-i586.tar /usr/local/java</span><br></pre></td></tr></table></figure></p><p>7.进入 /usr/local/java 目录,解压jdk到当前目录<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/java</span><br><span class="line">tar -xvf jdk-8u171-linux-i586.tar</span><br></pre></td></tr></table></figure></p><p>8.配置环境变量<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line">   </span><br><span class="line"><span class="meta">#</span> 在文件的最后面添加如下代码</span><br><span class="line">export JAVA_HOME=/usr/local/java/jdk1.7.0_72</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure></p><p>9.保存退出<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 在vim下，按shift + : 调出底部命令，输入wq (保存退出)，回车ok</span><br></pre></td></tr></table></figure></p><p>10.重新加载配置文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></p><p>11.查看jdk是否安装成功<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br><span class="line">[root@jason ~]# -bash: /usr/java/jdk1.7.0_71/bin/java: /lib/ld-linux.so.2: bad ELF interpreter: No such file or directory</span><br></pre></td></tr></table></figure></p><blockquote><p>  <strong>问题来了，出现了错误：No such file or directory。</strong></p><p>  <strong>原因：没有那个文件或目录，需要安装glibc</strong></p></blockquote><p>12.终端输入下面的命令，安装好glibc，问题解决,，再次查看jdk版本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install glibc.i686</span><br><span class="line">[root@jason ~]# java -version</span><br><span class="line">java version "1.8.0_171"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_171-b11)</span><br><span class="line">Java HotSpot(TM) Client VM (build 25.171-b11, mixed mode)</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>jdk安装完成！</strong></p></blockquote><h6 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h6><p>1.先准备好apache-tomcat安装包 (apache-tomcat-7.0.52.tar.gz)<br>2.在 /usr/local 新建一个文件夹tomcat<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/tomcat</span><br></pre></td></tr></table></figure></p><p>3.移动 apache-tomcat…tar.gz 到 /usr/local/tomcat<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv apache-tomcat-7.0.52.tar.gz /usr/local/tomcat/</span><br></pre></td></tr></table></figure></p><p>4.进入/usr/local/tomcat目录,解压Tomcat<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/tomcat</span><br><span class="line">tar -zxvf apache-tomcat-7.0.52.tar.gz</span><br></pre></td></tr></table></figure></p><p>5.进入 /usr/local/tomcat/apache-tomcat-7.0.52/bin<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/tomcat/apache-tomcat-7.0.52/bin</span><br></pre></td></tr></table></figure></p><p>6.启动tomcat(执行startup.sh文件)<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方式1:</span><br><span class="line">    sh startup.sh</span><br><span class="line">方式2:</span><br><span class="line">    ./startup.sh</span><br></pre></td></tr></table></figure></p><p>7.修改防火墙的规则，放行8080端口，同时在阿里云安全组规则中添加8080端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --add-port=8080/tcp --permanent</span><br></pre></td></tr></table></figure></p><p>8.查看服务器已开启的tcp端口<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@jason] # netstat -ntlp</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class="line">tcp        0      0 0.0.0.0:8009            0.0.0.0:*               LISTEN      3833/java</span><br><span class="line">tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      3833/java</span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      739/httpd</span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      2101/sshd</span><br><span class="line">tcp        0      0 127.0.0.1:8005          0.0.0.0:*               LISTEN      3833/java</span><br></pre></td></tr></table></figure></p><p>9.访问8080端口<br> <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://x.x.x.x:8080</span></span><br></pre></td></tr></table></figure></p><p><img src="https://toolife.github.io/images/ali_cloud/path_11.png" alt="path_11"></p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Linux </tag>
            
            <tag> Center OS </tag>
            
            <tag> 云服务器 </tag>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
